%
% PREAMBOLO
%
\RequirePackage[l2tabu, orthodox]{nag} % Pacchetto nag per controllo errori sorgente
\documentclass[11pt,UdineBachThesis,italian]{PhdThesis}  % laurea triennale
\StudyCourse{Corso di Laurea in Informatica}

\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage[autostyle,italian=guillemets]{csquotes} % necessario per biblatex
\usepackage[bibstyle=numeric,citestyle=numeric,backend=biber]{biblatex} % bibliografia
\usepackage{microtype} % tipografia
\usepackage{graphicx} % immagini
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{subfig} % sottofigure
\usepackage{lipsum} % lorem ipsum
\usepackage{listings} % codice
\usepackage{float}
\usepackage{varioref}
\usepackage[bookmarks=true,bookmarksopen=true,pdfhighlight=/I,pdfpagemode=UseOutlines]{hyperref} % questo va per ultimo


% Teoremi
\newtheoremstyle{indentdef}{.5\topsep}{.5\topsep}{\addtolength{\leftskip}{2.5em}}{-2.5em}{\bfseries}{.}{ }{}

\newtheorem*{dimo}{Dimostrazione}

\theoremstyle{indentdef}
\newtheorem{defi}{Definizione}[section]
\newtheorem{teo}{Teorema}[section]
\newtheorem{prop}{Proposizione}[section]
\newtheorem{cor}{Corollario}[section]
\newtheorem*{term}{Terminologia}
\newtheorem*{nota}{Notazione}

\theoremstyle{definition}

\theoremstyle{remark}
\newtheorem*{oss}{Osservazione}
\newtheorem*{esempio}{Esempio}

% Comandi aggiuntivi
\newcommand{\eqdef}{\stackrel{\text{\tiny def}}{=}} % equal con def sopra
\newcommand{\squote}[1]{\textquoteleft#1\textquoteright} % testo tra singlequote
\newcommand{\dquote}[1]{\textquotedblleft#1\textquotedblright} % testo tra doublequote
\newcommand{\addlisting}[2]{\lstinputlisting[numbers=left,breaklines,frame=TB,caption=#2]{#1}}

% Traduzioni
%\newtranslation[to=italian]{Section}{Sezione}
% Direttive
\renewcommand{\lstlistingname}{Codice}
\lstset{basicstyle=\small\ttfamily}
%\setlength{\parindent}{0pt} % togliere indentazione paragrafi
\graphicspath{{img/}}
\addbibresource{bib/milner_1540607.bib} % bibliografia
\addbibresource{bib/geatti_tesi_brs.bib} % bibliografia
\makeindex

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%			INIZIO DOC
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\title{Simulazione di Sistemi Reattivi Bigrafici}
\author{Elia Calligaris}
\email{eliac_mail@libero.it}
\supervisor{Prof. Marino Miculan}
\cosupervisor{Dott. Marco Peressotti}
\date{2014-2015}

\begin{document}
\pagestyle{empty}
\maketitle
\frontmatter
\begin{dedication}
\emph{A coloro che mi hanno donato la parola, \\
 ed a coloro che mi hanno insegnato ad usarla.}
\end{dedication}
\begin{abstract}
I bigrafi sono un meta-modello le cui potenzialità sono ancora oggetto di ricerca. In questa tesi si esporrà una parte di teoria dei bigrafi, per poi analizzarne un'implementazione in Java in grado di simulare sistemi basati su bigrafi. Per tali sistemi si vedrà come generare tutti gli stati possibili e come verificare delle proprietà in modo automatico. Verranno dati alcuni esempi.
\end{abstract}
\begin{acknowledgments}
Qualcuno disse che scrivere una tesi di laurea è una prova di maturità scientifica; senza ombra di dubbio, raggiungere tale maturità è un percorso lungo e non banale. Pertanto i miei ringraziamenti vanno soprattutto a coloro che mi hanno permesso di arrivare fin qui: i miei genitori, tutti i maestri e professori, gli amici, i compagni di classe e di corso.\\
Un ringraziamento particolare va a Luca Geatti: il parallelismo dei nostri lavori di tesi lo ha reso il mio collega più stretto in tutti questi mesi di studio, analisi, programmazione e scrittura. Il suo contributo è stato fondamentale.
\end{acknowledgments}

\partstyle{serifbig}
\chaptertitlestyle{serifbig}
\pagestyle{serif}
\tableofcontents
\listoffigures
\lstlistoflistings

%\begin{preface}
%    Here the preface
%\end{preface}
%\chapter*{Prefazione}
%\addcontentsline{toc}{chapter}{Prefazione}
%\lipsum

\mainmatter
\chapter{Introduzione}
%\pagestyle{empty}
%\addcontentsline{toc}{chapter}{Introduzione}

\chapter{Teoria dei bigrafi}\label{cap:teoria}
In questo capitolo si daranno definizioni formali dei bigrafi, delle loro componenti, e delle relative operazioni elementari e derivate; si vedrà come costruire un bigrafo a partire da bigrafi elementari, e si darà la definizione di \emph{BRS} (\emph{Sistema Reattivo Bigrafico}).

La teoria è estratta dall'ampia trattazione di Robert Milner \cite{Milner:SMCA}, e adattata per le ridotte necessità di questa tesi.

\section{Bigrafi e le loro componenti}\label{sec:componenti_bigrafi}

Un \emph{bigrafo} è un tipo particolare di grafo in cui i nodi possono essere annidati l'uno dentro l'altro, e gli archi sono \emph{iper-archi}, cioè collegano un punto di partenza a più punti di arrivo. Pertanto, come la parola \emph{bi-grafo} suggerisce, siamo in presenza di una struttura composta da due grafi indipendenti, dei quali uno descrive la topologia, e l'altro i collegamenti tra nodi.
Inoltre si possono definire diversi tipi di nodo con diverso significato: questo rende i bigrafi un \emph{meta-modello}, in modo simile all'XML. 

\begin{figure}[h]
\begin{center}
%\def \svgwidth{ 2 \textwidth / 3}
%\input{img/big_esempio_nonomi.pdf_tex}
\includegraphics[width=2 \textwidth /3]{big_esempio_nonomi.pdf}
\end{center}
\caption{Esempio di bigrafo.}
\end{figure}

\subsection{Segnature e controlli}\label{ssec:segnature}

Data la generalità dei bigrafi, è innanzitutto necessario definire il significato dei nodi: per far ciò gli si assegnano dei \emph{controlli}.
\begin{defi}[Controllo]
Un \emph{controllo} $K$ è il tipo di un nodo.
\end{defi}
Ogni nodo ha un solo controllo, ed ogni controllo è tipicamente definito con un nome. La possibilità di creare ed assegnare controlli ai nodi permette di definirne il significato a piacere, garantendo una grande libertà semantica. Per fare un paragone con la programmazione orientata agli oggetti, un nodo sta al suo controllo come un'istanza sta alla sua classe.
\begin{term}[K-nodo]
Con l'espressione \emph{K-nodo} si intende un nodo il cui controllo è $K$.
\end{term}
Ora, siccome ogni bigrafo avrà (tipicamente) più di un tipo di nodo, è necessario definirne l'insieme dei controlli.
\begin{defi}[Segnatura]
Una \emph{segnatura} è una coppia $(K,ar)$, dove $K$ è un insieme di controlli e $ar$ è una funzione $K\rightarrow \mathbb{N} $, che mappa ad ogni nodo la sua arietà (numero di porte).
\end{defi}

\begin{defi}[Porta]
Una \emph{porta} è un \dquote{punto} dal quale partono o terminano i collegamenti (archi).
\end{defi}

\begin{oss}
Tramite la segnatura, si accoppia il controllo di un nodo al suo numero di porte biunivocamente; le porte sono ordinate e non intercambiabili.
\end{oss}

\begin{nota}
Per semplicità, le segnature possono essere descritte come segue:
\begin{center}
$K = \{ K_1:a_1, \dots, K_n:a_n \}$ intendendo che il controllo $K_i$ ha arietà $a_i$.
\end{center}
\end{nota}

Quindi tramite la segnatura si ha già una prima caratterizzazione del bigrafo in termini di semantica ed arietà dei nodi. Con questo fondamento si può passare ad analizzare la topologia e le relazioni tra nodi.

\subsection{\foreignlanguage{english}{Place graph}}\label{ssec:place_graph}
Il place graph è una foresta che descrive la topologia del bigrafo; in altre parole, indica come sono annidati i nodi. Ogni albero della foresta inizia con una \emph{radice} (o \emph{regione}); ogni radice è etichettata con un numero che va da $0$ a $n-1$, dove $n$ è il numero di radici.
Ogni nodo può contenere un \emph{sito}, che indica la possibilità che vi siano altri nodi all'interno di quel nodo.

\begin{figure}[t]
\begin{center}
\subfloat[Bigrafo]{\includegraphics{big_esempio_nonomi.pdf}}\qquad
\subfloat[Place graph]{\includegraphics{place_esempio.pdf}}
\end{center}
\caption{Esempio di bigrafo e relativo place graph.}
\end{figure}

\begin{term}[Posto]
Gli elementi del place graph sono detti \emph{posti}.
\end{term}

\begin{nota}
Con $A\uplus B$ si intende l'unione di insiemi che si sa o si assume essere fra loro disgiunti.
\end{nota}

\begin{defi}[Place graph]
Un \emph{place graph} è una tripla $(V,ctrl,prnt):m\rightarrow n$ dove:
\begin{itemize}
\item $V$ è l'insieme dei nodi;
\item $ctrl$ è la mappa $V\rightarrow K$ che assegna ad ogni nodo un controllo;
\item $m$ è l'\emph{interfaccia interna} ed $n$ l'\emph{interfaccia esterna}; rappresentano rispettivamente il numero di siti e di radici, pertanto sono entrambe rappresentate da numeri finiti;
\item $prnt$ è la mappa (aciclica) $m \uplus V \rightarrow V \uplus n$, che assegna ad ogni nodo il suo genitore (se c'è).
\end{itemize}
\end{defi}

\subsection{Link graph}\label{ssec:link_graph}
Il link graph è un \emph{ipergrafo} (cioè un grafo i cui archi possono connettere più nodi) non orientato che descrive il collegamento fra i vari nodi del bigrafo (o meglio, tra le loro porte). Il link graph descrive anche dei potenziali collegamenti con altri bigrafi grazie alle interfacce descritte dagli \emph{inner names} e dagli \emph{outer names}: gli outer names indicano l'interfaccia verso l'esterno, a cui possono collegarsi anche altri bigrafi; gli inner names (interfaccia interna) descrivono l'interfaccia dei bigrafi che possono aggiunti per composizione (si veda il paragrafo \ref{ssec:op_costruzione}). 

\begin{figure}[ht]
\begin{center}
\subfloat[Bigrafo]{\setlength\fboxsep{10pt}
\fbox{\input{img/big_esempio_nomi.pdf_tex}}}\qquad
\subfloat[Link graph]{ \setlength\fboxsep{10pt}
\fbox{\input{img/link_esempio.pdf_tex}}}
\end{center}
\caption{Esempio di bigrafo e relativo link graph.}
\end{figure}

\begin{term}[Punti e link] \foreignlanguage{english}{Inner names} e porte vengono chiamati \emph{punti}; \foreignlanguage{english}{outer names} e archi vengono chiamati \emph{link}. Gli archi sono detti \emph{link chiusi}, mentre gli outer names sono detti \emph{link aperti}.
\end{term}

\begin{defi}
Un link graph è una tupla $(V,E,ctrl,link):X\rightarrow Y$ dove:
\begin{itemize}
\item $V$ ed $E$ sono, rispettivamente, gli insiemi (finiti) dei nodi e degli (iper)archi;
\item $ctrl$ è la mappa dei controlli $V\rightarrow K$;
\item $X$ e $Y$ sono, rispettivamente, le \emph{interfacce interna} e \emph{esterna}, composte dagli \emph{\foreignlanguage{english}{inner names}} e dagli \emph{\foreignlanguage{english}{outer names}};
\item $link$ è la mappa $X \uplus P \rightarrow E \uplus Y$, dove $P = \{(v,i) : v \in V, i \in ar(ctrl(v)) \}$ è l'insieme delle porte.
\end{itemize}
\end{defi}

\begin{term}[Idle]
Un posto senza figli o un link senza punti è detto \emph{idle}.
\end{term}

\subsection{Bigrafo}\label{ssec:bigrafo}
Definendo le strutture che compongono i bigrafi, si è parlato più volte di \emph{interfacce}. Ora verranno definite formalmente.
\begin{defi}[Interfaccia]
Un'\emph{interfaccia} per bigrafi è una coppia $\langle m,X\rangle$, dove $m \in \mathbb{N}$ è detta \emph{larghezza}, mentre $X$ è l'insieme dei nomi.
\end{defi}

Detto questo, si può dare una definizione formale di bigrafo.

\begin{defi}[Bigrafo]
Un \emph{bigrafo} è una tupla 
\begin{center}
$(V,E,ctrl,prnt,link):\langle m,X\rangle \rightarrow \langle n,Y\rangle$
\end{center}
dove $\langle m,X\rangle$ è detta \emph{interfaccia interna}, mentre $\langle n,Y\rangle$ è detta \emph{interfaccia esterna}.
\end{defi}
\begin{oss}
Un bigrafo $B$ è composto da:
\begin{itemize}
\item un place graph $B^P=(V,ctrl,prnt):m\rightarrow n$;
\item un link graph $B^L=(V,E,ctrl,link):X\rightarrow Y$.
\end{itemize}
Che sono strutture ortogonali ed indipendenti. Pertanto, un bigrafo si può definire anche come una coppia $\langle B^P,B^L\rangle$.
\end{oss}

\begin{figure}[ht]
\begin{center}
\subfloat[Bigrafo $B$]{\setlength\fboxsep{10pt}
\fbox{\input{img/big_esempio_nomi2.pdf_tex}}}\qquad
\subfloat[Place graph $B^P$]{\setlength\fboxsep{10pt}
\fbox{\includegraphics{place_esempio.pdf}}}
\subfloat[Link graph $B^L$]{ \setlength\fboxsep{10pt}
\fbox{\input{img/link_esempio.pdf_tex}}}
\end{center}
\caption{Esempio di bigrafo e sua scomposizione.}
\end{figure}

\begin{term}(Ground, agente)
Un bigrafo la cui interfaccia interna è vuota viene detto \emph{ground} o \emph{agente}. Ne viene indicata solo l'interfaccia esterna.
\end{term}

\begin{nota}
I bigrafi generici vengono indicati con lettere maiuscole ($A$,$B$,$C$,\dots), mentre gli agenti vengono indicati con lettere minuscole ($a$,$b$,$c$,\dots).
\end{nota}

%Ciao Sorting!

% % % Operazioni sui bigrafi
\section{Operazioni sui bigrafi}\label{sec:op_bigrafi}
Ora si andranno a definire alcune operazioni sui bigrafi e la loro algebra, con lo scopo di fornire il necessario per poter costruire bigrafi complessi a partire da quelli elementari. Tali operazioni saranno fondamentali anche per poter descrivere l'evoluzione dei sistemi reattivi bigrafi (sez. \ref{sec:evoluzione_bigrafi}).

\subsection{Operazioni di base}\label{ssec:op_base}
\begin{nota}
Con $Id_I$ si indica la funzione identità sull'insieme $I$.
\end{nota}

\begin{defi}[Supporto] % spostare in Bigrafo? anche no
Ad ogni link graph, place graph, o bigrafo $B$ viene assegnato un insieme finito $|B|$ detto \emph{supporto}.
Per un place graph $|B|=V$, mentre per link graphs e bigrafi $|B|=V\uplus E$.
\end{defi}
\begin{defi}[Traduzione di supporto] % biezione? biiezione?
Per due bigrafi $F$ e $G$, una \emph{traduzione di supporto} $\rho: |F|\rightarrow |G|$ è una coppia di biiezioni $\rho_V:V_F\rightarrow V_G$ e $\rho_E:E_F\rightarrow E_G$ che ne rispetta la struttura, ovvero:
\begin{itemize}
\item $\rho$ preserva i controlli, cioè $ctrl_G \circ \rho_V = ctrl_F$; ne consegue che $\rho$ induce una biiezione $\rho_P:P_F \to P_G$ sulle porte, definita da $\rho_P((v,i)) \eqdef (\rho_V(v),i)$. 
\item $\rho$ commuta con le mappe strutturali come segue:
 \subitem per i posti: $prnt_G \circ \left( id_m \uplus \rho_V \right) = \left( id_n \uplus \rho_V \right) \circ prnt_F$
 \subitem per punti e link: $link_G \circ \left( id_X \uplus \rho_P \right) = \left( id_Y \uplus \rho_E \right) \circ link_F$
\end{itemize}
Dati $F$ e la biiezione $\rho$, sotto queste condizioni è possibile determinare univocamente $G$; pertanto si dice che $G=\rho \cdot F$ è la traduzione di supporto di $F$ per $\rho$.
\end{defi}

\begin{defi}[Equivalenza sul supporto]
Diremo che $F$ e $G$ sono \emph{support equivalent} (hanno supporti equivalenti) e si scriverà $F \bumpeq G$,
se e solo se esiste una traduzione di supporto tra $F$ e $G$.
\end{defi}

\subsection{Operazioni di costruzione}\label{ssec:op_costruzione} 
Verranno ora illustrate le principali operazioni di costruzione di bigrafi.

\begin{defi}[Composizione]
Dati due bigrafi con supporti disgiunti
\begin{center}
 $F:\left<m,X\right> \to \left<k,Z\right>$ , $G:\left<k,Z\right> \to \left<n,Y\right>$
\end{center}
la composizione $H = G \circ F : \left<m,X\right> \to \left<n,Y\right>$ è il bigrafo
\begin{center}
 $H = G \circ F = (V_F \uplus V_G , E_F \uplus E_G , ctrl_F \uplus ctrl_G , prnt_H , link_H )$
\end{center}
dove:
\begin{center}
$prnt_H(w) = 
\begin{cases}
 prnt_F(w) & \text{se } w \in m \uplus V_F \wedge prnt_F(w) \in V_F\\
 prnt_G(j) & \text{se } w \in m \uplus V_F \wedge prnt_F(w) = j \in k\\
 prnt_G(w) & \text{se } w \in V_G
\end{cases}$\\
$link_H(q) =
\begin{cases}
 link_F(q) & \text{se } q \in X \uplus P_F \wedge link_F(q) \in E_F\\
 link_G(z) & \text{se } q \in X \uplus P_F \wedge link_F(q) = z \in Z\\
 link_G(q) & \text{se } q \in P_G
\end{cases}$\\
\end{center}
con $P_F$ e $P_G$ insiemi delle porte, come definiti nella sezione del link graph.
\end{defi}

\begin{oss}
La composizione richiede che l'interfaccia esterna di $F$ sia uguale a quella interna di $G$.
\end{oss}

\begin{term}[Contesto]
Un bigrafo composto con un agente viene detto \emph{contesto}.
\end{term}

\begin{defi}[Bigrafo identità]
Il \emph{bigrafo identità} su $\left<m,X\right>$ è \begin{center}
$id_{\left<m,X\right>} = (\emptyset , \emptyset, \emptyset_K , id_m , id_X)$.
\end{center}
\end{defi}

\begin{defi}[Bigrafi disgiunti]
Due bigrafi $F_i:\langle m_i,X_i\rangle \to \langle n_i,Y_i\rangle $ ($i=0,1$) sono \emph{disgiunti} se $|F_i|$,$X_i$ e $Y_i$ sono (rispettivamente) fra loro disgiunti.
\end{defi}

\begin{defi}[Giustapposizione]
Dati due bigrafi disgiunti:
\begin{center}
$F:\left<m_F,X_F\right> \to \left<n_F,Y_F\right>$ , $G:\left<m_G,X_G\right> \to \left<n_G,Y_G\right>$
\end{center}
la loro giustapposizione $F \otimes G:\left<m_F+m_G , X_F \uplus X_G\right> \to \left<n_F+n_G , Y_F \uplus Y_G\right>$ è il bigrafo
\begin{center}
 $F \otimes G = (V_F \uplus V_G ,\ E_F \uplus E_G ,\ ctrl_F \uplus ctrl_G ,\ prnt_F \uplus prnt^\prime_G ,\ link_F \uplus link_G)$
\end{center}
dove $prnt^\prime_G(m_F+i) = n_F + j$ ogni qualvolta $print_G(i) = j$.
\end{defi}

\begin{oss}
Nella giustapposizione tra bigrafi l'interfaccia unità è $\epsilon = \langle 0,\emptyset \rangle$.
\end{oss}

\subsection{Algebra dei bigrafi}\label{sec:algebra_bigrafi}
Ora si mostrerà come i bigrafi possono essere costruiti a partire da bigrafi più piccoli, per via di composizioni, prodotti ed identità.
Verranno descritti i bigrafi elementari e le loro forme normali.

\begin{defi}[Placing, permutazione, merge]
Un \emph{placing} ($\phi$) è un bigrafo senza né nodi né link.
Un placing biiettivo dai siti alle radici (ovvero che per ogni radice ha un solo sito) è una \emph{permutazione} ($\pi$).
Un placing con una radice ed $n$ siti è denotato con $merge_n$.
Vengono definiti tre placing detti \emph{elementari}:
\begin{figure}[h]
\begin{center}
\subfloat{\input{img/placing_elem1.pdf_tex}}\quad
\centering
\subfloat{\input{img/placing_elem2.pdf_tex}}\qquad
\subfloat{\input{img/placing_elem3.pdf_tex}}
\end{center}
\caption{Placing elementari.}
\end{figure}
\end{defi}

\begin{oss}
Tutte le permutazioni possono essere costruite a partire dalla simmetria elementare $\gamma_{1,1}$; tutti i placings possono essere costruiti a partire da $\gamma_{1,1}$, $1$ e $join$.
\end{oss}
\begin{esempio}
$merge_0 = 1$ e $merge_{n+1}= join \circ (id_I \otimes merge_n)$
\end{esempio}

\begin{defi}[Linking, sostituzione, chiusura]
Un \emph{linking} ($\lambda$) è un bigrafo senza posti. I linkings sono generati per composizione, prodotto e identità a partire da \emph{sostituzioni elementari} $y/X$ e \emph{chiusure elementari} $/x:x\to \epsilon$ (si veda la figura \ref{fig:linking_elem}).

Una \emph{sostituzione} ($\sigma$) è il prodotto di sostituzioni elementari; una \emph{chiusura} è il prodotto di chiusure elementari.

La sostituzione vuota è $x:\epsilon \to x$.
\end{defi}
\begin{figure}[h]
\begin{center}
\subfloat[Sostituzione elementare]{\input{img/linking_elem1.pdf_tex}}\qquad
\centering
\subfloat[Chiusura elementare]{\qquad\qquad\input{img/linking_elem2.pdf_tex}}
\end{center}
\caption{Linking elementari.}
\label{fig:linking_elem}
\end{figure}

\begin{term}[Rinomina]
Una sostituzione biiettiva è detta \emph{rinomina} ($\alpha$).
\end{term}

\begin{prop}[Isomorfismo]
Isomorfismi tra place graphs e link graphs sono, rispettivamente, permutazioni $\pi$ e rinomine $\alpha$; isomorfismi tra bigrafi sono coppie $\langle \pi,\alpha \rangle$.
\end{prop}

C'è solo un tipo di bigrafo elementare che introduce nodi: l'\emph{ione}.
\begin{defi}[Ione]
Per ogni controllo $K : n$, il bigrafo 
 $K_{\vec{x}}: 1 \to \left< 1 , \{ x_1 , \ldots , x_n \} \right>$ 
avente un unico nodo $K$ le cui porte sono collegate biiettivamente con $n$ 
distinti nomi ed un unico sito all'interno di $K$, è detto \emph{ione discreto} (o più semplicemente, \emph{ione}).
\begin{figure}[h]
\begin{center}
\def\svgwidth{\textwidth/3}
\input{img/ione.pdf_tex}
\end{center}
\caption{Ione.}
\end{figure}
\end{defi}

\begin{defi}[Primo, discreto]
% controllare traduzione homset
Un bigrafo \emph{primo} con interfaccia $m\to\langle X\rangle$ è privo di inner names, e ha una sola radice. Un bigrafo (o link graph) è \emph{discreto} se non ha link chiusi, e la sua mappa dei link è biiettiva.  
\end{defi}

\begin{oss}
$merge_n:n\to 1$ è un primo importante, in quanto non ha nodi e mappa $n$ siti in una singola radice.
\end{oss}

\begin{defi}[Atomo, molecola]
Se il sito di un K-ione discreto è riempito da $1:0\to 1$ (placing elementare), il risultato è un \emph{atomo} discreto $K_{\vec{x}}\circ 1$; se è riempito da un bigrafo discreto $G: I \to \langle 1,Y\rangle$ è una \emph{molecola} discreta $(K_{\vec{x}} \otimes id_Y)\circ G$. 
\begin{figure}[h]
\begin{center}
\subfloat[Atomo]{\input{img/atomo.pdf_tex}}
\centering
\subfloat[Molecola]{\qquad\input{img/molecola.pdf_tex}}
\end{center}
\caption{Atomo e molecola.}
\end{figure}
\end{defi}

\begin{oss}
L'identità $id_I$ è importante qua: permette ai nodi di $C_1$ di avere figli in $C_2$ ed $F$, e permette a $C_1$ e $C_2$ di condividere link che non coinvolgono $F$.
\end{oss}

\begin{prop}[Forma Normale Discreta]
Ogni bigrafo $G:\left<m,X\right> \to \left<n,Z\right>$
può essere espresso univocamente, a meno di rinomine su $Y$, come
\begin{center}
 $G = (id_n \otimes \lambda) \circ D$
\end{center}
dove $\lambda:Y \to Z$ è un linking e $D:\left<m,X\right> \to \left<n,Y\right>$ è discreto.
Inoltre, ogni bigrafo discreto $D$ può essere fattorizzato univocamente, a meno di permutazione dei siti per ogni fattore, come
\begin{center}
 $D = \alpha \otimes ((P_0 \otimes \cdots \otimes P_{n-1}) \circ \pi)$
\end{center}
con $\alpha$ un renaming, ogni $P_i$ primo e discreto e $\pi$ una permutazione di tutti i siti.
\end{prop}
Si noti che il renaming $\alpha$ è discreto ma non primo, dato che ha $width=0$ e possiede inner names.
Nel caso in cui il grafo $D$ sia ground, il risultato può essere semplificato come segue:
\begin{cor}[Forma Normale Discreta per Bigrafi Ground]
Un bigrafo ground $g:\left<n,Z\right>$ è fattorizzabile in modo univoco, a meno di rinomine su $Y$, come
\begin{center}
 $g=(id_n \otimes \lambda) \circ (d_0 \otimes \cdots \otimes d_{n-1})$
\end{center}
dove $\lambda : Y \to Z$ sono linking e $d_i$ sono bigrafi discreti e primi.
\end{cor}

Questa scomposizione di un bigrafo in bigrafi discreti più piccoli è cruciale per dimostrare la completezza
della teoria algebrica dei bigrafi (\cite{Milner:SMCA}). 

\subsection{Operazioni derivate}\label{ssec:op_derivate}

\begin{nota} 
Spesso si omette \squote{$\cdots \otimes id_I$} in una composizione del tipo
$(F \otimes id_I) \circ G$, dove $F$ non possiede un'interfaccia sufficiente per comporre con $G$. Si scriverà dunque,
qualora non presenti ambiguità, $F \circ G$.
Dato un linking $\lambda : Y \to Z$, potremmo volerlo applicare ad un bigrafo $G$ con interfaccia esterna $\left<m,X\right>$
avente meno nomi, i.e. $Y = X \uplus X^\prime$. Scriveremo allora $\lambda \circ G$ per indicare
$(id_m \otimes \lambda) \circ (G \otimes X^\prime)$, quando $m$ e $X^\prime$ possono essere capiti dal contesto.

Se $X=\{x_1,\dots,x_n\}$ si scriverà $/X$ per intendere $/x_1 \otimes \dots \otimes x_n$.
\end{nota}

\begin{defi}[Prodotto parallelo]
Siano $G_i:\langle m_i,X_i\rangle\to\langle n_i,Y_i\rangle$ ($i=0,1$) due bigrafi i cui supporti sono disgiunti e per cui $link_0\cap link_1$ è una funzione; Allora il loro \emph{prodotto parallelo} %($\parallel$) 
\begin{center}
$G_0\parallel G_1\eqdef\langle m_0+m_1,X_0\cup X_1\rangle\to\langle n_0+n_1,Y_0\cup Y_1\rangle$
\end{center}
è definito proprio come la giustapposizione, eccetto per il fatto che la mappa dei link permette la condivisione dei nomi.
\end{defi}

\begin{prop}[Proprietà di $\parallel$]
Il prodotto parallelo ha la \emph{proprietà associativa}, ovvero $F \parallel ( G \parallel H) = (F \parallel G) \parallel H$, ed ha $id_\epsilon$ come unità; inoltre soddisfa la \emph{proprietà \squote{bifuntoriale}}, se ambo le parti sono definite:
\begin{center}
$(F_1 \parallel G_1) \circ (F_0 \parallel G_0) = (F_1 \circ F_0) \parallel (G_1 \circ G_0)$
\end{center}
\end{prop}
\begin{dimo}
La dimostrazione segue linearmente dalla definizione, una volta notato che la condizione sulle mappe dei link è soddisfatta da una parte se e solo se è soddisfatta anche dall'altra.\qed
\end{dimo}

\begin{defi}[Annidamento]
Dati i bigrafi $F:I\to\langle m,X\rangle$ e $G:m\to\langle n,Y\rangle$, il loro \emph{annidamento} $G.F: I \to \langle m,X\cup Y\rangle$ è definito come:
\begin{center}
$G.F\eqdef (id_X\parallel G)\circ F$
\end{center}
\end{defi}
% exempio milner

\begin{defi}[Prodotto Merge]
Il prodotto merge ($|$) di due bigrafi $G_i:\left<m_i,X_i\right> \to \left<n_i,Y_i\right>$ $(i=0,1)$, il cui prodotto parallelo esiste, è definito come:
\begin{center}
 $G_0 \mid G_1 = merge_{n_0+n_1} \circ ( G_0 \parallel G_1 ): \left< m_0 + m_1 , X_0 \cup X_1\right> \to \left< 1 , Y_0 \cup Y_1\right>$
\end{center}
\end{defi}

\begin{prop}[Proprietà di $\mid$]
Il prodotto merge gode della \emph{proprietà associativa} e (su bigrafi di larghezza unitaria) ha 1 come unità.
\end{prop}

\section{Evoluzione dei bigrafi}\label{sec:evoluzione_bigrafi}
Il uno dei motivi per cui i bigrafi sono un formalismo interessante è la loro capacità di evolvere.

\begin{defi}[Reazione]
Una \emph{reazione} $F\to F'$ è una trasformazione da un bigrafo $F$ ad un bigrafo $F^\prime$.
\end{defi}

\begin{defi}[Segnatura dinamica]
Una segnatura è detta \emph{dinamica} se associa ad ogni controllo $K$ uno \emph{stato} nell'insieme $\{attivo,passivo\}$.
Un K-nodo è detto attivo se il suo controllo è attivo. Le regioni sono sempre attive.
Un sito è attivo se tutti i suoi antenati nel place graph sono attivi. Un bigrafo è attivo se tutti i suoi siti
sono attivi.
\end{defi}

\begin{oss}
Un K-nodo passivo, e conseguentemente tutti i suoi discendenti, sono inibiti al prendere parte alle reazioni.
\end{oss}

Definito cosa intendiamo per reazione, ora è necessario formalizzare un modo per rappresentare il \emph{modo} in cui queste reazioni avvengono; ciò viene ottenuto definendo delle \emph{regole di riscrittura}.

\subsection{Regole di riscrittura}\label{ssec:regole_riscrittura}

\begin{defi}[Regola di riscrittura]\label{def:regola_riscrittura}
Una \emph{regola di riscrittura} $R\to R^\prime$ definisce una reazione $a\to a'$, dove:
\begin{itemize}
\item $a = C\circ (R\otimes id_I)\circ d$;
\item $a'= C\circ (R'\otimes id_I)\circ d$;
\item $C$ è attivo;
\item $a$, $a'$ e $d$ sono \emph{ground}(\emph{agenti});
\item $R$ ed $R'$ hanno una stessa interfaccia $I$.
\end{itemize}
\end{defi}
\begin{term}[Redex, Reactum]
$R$ è detto \emph{redex}, $R'$ è detto \emph{reactum}.
\end{term}

\begin{figure}[h]
\begin{center}
\def \svgwidth{0.8 \textwidth}
\input{img/regola_reazione.pdf_tex}
\end{center}
\caption[Esempio di regola di riscrittura.]{Esempio di regola di riscrittura. A sinistra della freccia c'è il redex, a destra c'è il reactum}
\end{figure}

In buona sostanza, quando si applica una regola di riscrittura ad un bigrafo $B$, si va a cercare un'\emph{occorrenza} del redex in $B$, e la si sostituisce con il reactum. Ora si formalizzerà questo procedimento.

\begin{defi}[Occorrenza]
Un bigrafo $F$ \emph{occorre} in un bigrafo $G$ se l'equazione $C_1 \circ (F \otimes id_I) \circ C_2$ è vera per qualche interfaccia $I$ e bigrafo $C_1$ e $C_2$.
\end{defi}

\begin{term}[Matching, contesto, parametro] La ricerca dell'occorrenza di un bigrafo $F$ in uno $G$ viene detta \emph{matching}. I risultati del matching vengono chiamati \emph{match}, indicati con  $M = C \circ (F \otimes id_I) \circ D$; $C$ viene detto
\emph{contesto} mentre $D$ viene chiamato \emph{vettore di parametri} (o, più semplicemente, \emph{parametro}).
\end{term}

\begin{oss}
Con riferimento alla definizione \ref{def:regola_riscrittura}, il fatto che $R$ ed $R^\prime$ debbano avere la stessa interfaccia è un vincolo molto forte:
infatti non ciò consente di fare, per esempio, la copia del contenuto di un nodo in un altro, o lo scambio
dei contenuti di due nodi in regioni differenti (mantenendo inalterata la loro posizione).
\end{oss}
Per rilassare questo vincolo, si va a definire una mappa tra le interfacce del redex e del reactum.

\begin{defi}[Mappa d'istanziazione]
Siano $R$ ed $R^\prime$ due bigrafi con, rispettivamente, $\left<m,X\right>$ e $\left<m^\prime,X\right>$ come interfacce interne. Una \emph{mappa d'istanziazione} è una funzione
$\eta : m^\prime \to m$ che mappa siti di $R^\prime$ in siti di $R$.
\end{defi}

\begin{defi}[Funzione istanza/istanziamento]
Una \emph{funzione istanza} $\bar{\eta}$, data una mappa d'istanziazione $\eta : m^\prime \to m$, e dato un agente $g:\left<m,X\right>$ la cui Forma Normale Discreta è $g = \lambda \circ ( d_0 \otimes \cdots \otimes d_{m-1} )$, è definita come:
\begin{center}
 $\bar{\eta}(g) \eqdef \lambda \circ ( d^\prime_0 \parallel \cdots \parallel d^\prime_{m^\prime - 1} )$, con $d^\prime_i \bumpeq d_{\eta(i)}$.
\end{center}
\end{defi}

Grazie alle mappe di istanziazione è possibile definire una forma più espressiva di regola di riscrittura.

\begin{defi}[Regola di riscrittura parametrica]
Una regola di riscrittura $R\to R'$, affiancata da una mappa d'istanziazione $\eta$, è detta \emph{regola di riscrittura parametrica}.
Dato un \emph{agente} $a$, dove $R$ occorre in $a$, la regola di riscrittura parametrica produce la seguente reazione $a\to a'$, dove:
\begin{itemize}
\item $a = C \circ (R \otimes id_I) \circ d$;
\item $a' = C \circ (R^\prime \otimes id_I) \circ \bar{\eta}(d)$;
\item $\bar{\eta}$ è la funzione istanza su $\eta$. 
\end{itemize}
\end{defi}

\begin{oss} Ogni regola di riscrittura si può scrivere come una regola di riscrittura parametrica che ha come mappa d'istanziazione la funzione identità.
\end{oss}

\begin{term} In seguito, con la locuzione \emph{regola di riscrittura}, si indicheranno le regole di riscrittura \emph{parametriche}.
\end{term}

\subsection{BRS - Sistema Reattivo Bigrafico}\label{ssec:brs}
Definite le regole di scrittura, si vuole accoppiare la semantica del bigrafo (definita dalla segnatura) all'insieme di regole che ne causano l'evoluzione. Ciò viene fatto dal \emph{BRS}.

\begin{defi}[Sistema Reattivo Bigrafico - BRS]
Un \emph{Sistema Reattivo Bigrafico} (BRS) è definito da una coppia $(K , \mathcal{R})$, dove $K$  è una segnatura ed $\mathcal{R}$ è un insieme di regole
di riscrittura; pertanto viene indicato con $BG(K,\mathcal{R})$.
 L'insieme $\mathcal{R}$ è chiuso rispetto all'\emph{equivalenza sul supporto}: se $R \bumpeq S$ e $R^\prime \bumpeq S^\prime$ e $(R,R^\prime,\eta) \in \mathcal{R}$ per un certo $\eta$, allora $(S,S^\prime,\eta) \in \mathcal{R}$.
\end{defi}

Pertanto, dato un agente $a$ con segnatura $K$, $BG(K,\mathcal{R})$ permette di calcolare tutti gli agenti $a'$ che si possono ottenere facendo reagire $a$ un numero indeterminato di volte, ovvero gli $a':a\to_* a'$.


Nel capitolo \vref{cap:simulazione_brs} sarà illustrato un modo di implementare e simulare il BRS, nonché di ottenere tutti gli stati possibili del sistema da esso.

% % % % % % % % % % % % % % % % % % % % % % % 
%			CAP 2							%
% % % % % % % % % % % % % % % % % % % % % % % 
\chapter{Visualizzare i Bigrafi}\label{cap:visualizzare_bigrafi}
Prima di trattare la simulazione dei sistemi reattivi bigrafici, sarebbe interessante trovare il modo di visualizzare i bigrafi su calcolatore nel modo migliore possibile. Tuttavia generare in modo automatico una rappresentazione grafica dei bigrafi è un problema complicato, che non è stato ancora trattato a sufficienza. Pertanto, come punto di partenza, in questo capitolo si fornirà un metodo di rappresentazione testuale; in seguito, si indicherà come produrre una rappresentazione grafica semplificata.

\section{Rappresentazione testuale di bigrafi}
La libreria che si utilizzerà per implementare i BRS (si veda la sez. \vref{sec:jlibbig}) fornisce già un metodo per rappresentare un bigrafo con del testo, ovvero il metodo \texttt{Bigraph.toString()}\footnote{\texttt{Bigraph} è la classe che modella i bigrafi, si veda la sez. \vref{sec:rappresentare_bigrafi}}; tuttavia il formato, come si può vedere sotto, è poco leggibile. 

\addlisting{lst/car_toString.txt}{{[Risultato di \texttt{Bigraph.toString()} sul bigrafo \ref{fig:esempio_rappr_grafica}]Risultato di \texttt{Bigraph.toString()} sul bigrafo \vref{fig:esempio_rappr_grafica}}}

Ci si propone di migliorare la situazione andando a definire una classe \emph{pretty-printer}: tale classe legge un oggetto \texttt{Bigraph}, costruendone una sua rappresentazione interna (ad albero); tale struttura viene poi convertita in testo, secondo i seguenti criteri:
\begin{itemize}
\item si vogliono rappresentare nodi e relativi controllo, proprietà e porte; 
\item si vuole rappresentare la gerarchia dei nodi indentando il testo;
\item si vogliono visualizzare in modo particolare alcune proprietà; in, particolare le propietà con nome del tipo \emph{``*Name"}, vengono visualizzate come nome del relativo nodo.
\end{itemize}

\addlisting{lst/car_prettyPrint.txt}{{[\emph{Pretty-print} del bigrafo \ref{fig:esempio_rappr_grafica}]\emph{Pretty-print} del bigrafo \vref{fig:esempio_rappr_grafica}}}

Come si può notare, il formato prodotto è più leggibile, ma non con la stessa immediatezza di una rappresentazione grafica.

\section{Rappresentazione grafica di bigrafi}
Come anticipato, non esiste un algoritmo preciso ed affidabile per generare automaticamente la rappresentazione grafica dei bigrafi; al contrario, il campo della visualizzazione dei grafi è stato soggetto ad estesa ricerca, e sono disponibili algoritmi, linguaggi e programmi già pronti. Pertanto si è deciso di fornire una rappresentazione semplificata dei bigrafi in questo modo:
\begin{itemize}
\item[1.] un \emph{parser} trasforma il bigrafo in un grafo orientato, rappresentato in \emph{DOT Language};
\item[2.] si usa il tool \emph{GraphViz} per trasformare il file \emph{dot} in un'immagine vettoriale \emph{svg};
\item[3.] a questo punto si può visualizzare l'immagine con un \emph{browser}, o un visualizzatore che ne supporta il formato; altrimenti si può convertirla nel formato ritenuto più opportuno.
\end{itemize}
Un esempio del risultato di questa procedura è rappresentato dalla figura \vref{fig:esempio_render_graphviz}.
\paragraph{Strumenti impiegati} Il \emph{parser} citato al punto 1 è implementato dalla classe \texttt{DotLangPrinter}, che internamente funziona in modo simile al \emph{pretty-printer}. 

Il \emph{DOT Language} è un formalismo nato per rappresentare grafi orientati e non orientati, permettendo di specificare proprietà per i nodi come colore, forma etichetta, etc\dots

\emph{GraphViz} è un programma \emph{open-source} che genera immagini di grafi, data la loro descrizione in DOT. \`E reperibile su \url{http://www.graphviz.org/}.

\begin{figure}[]
\begin{center}
\includegraphics [width=\textwidth]
{car_example_graphviz.pdf}
\end{center}
\caption[\emph{Render} di GraphViz di un bigrafo in DOT]{\emph{Render} di GraphViz del codice \vref{lst:esempio_dot}.}
\label{fig:esempio_render_graphviz}
\end{figure}

\begin{figure}[]
\begin{center}
\def \svgwidth{0.9 \textwidth} \input{img/car_example.pdf_tex}
\end{center}
\caption[Esempio di bigrafo (dalla sez. \ref{sec:viaggio_macchina}).]{Bigrafo da rappresentare (si veda la sez. \vref{sec:viaggio_macchina}).}
\label{fig:esempio_rappr_grafica}
\end{figure} 

\lstinputlisting[label=lst:esempio_dot,breaklines,float,frame=L,caption={
[Rappresentazione in DOT (ridotta) del bigrafo in figura \ref{fig:esempio_rappr_grafica}]
Rappresentazione in DOT (ridotta) del bigrafo \vref{fig:esempio_rappr_grafica}.}
]{lst/car_example_redux.dot}
% % % % % % % % % % % % % % % % % % % % % % % 
%			CAP 3							%
% % % % % % % % % % % % % % % % % % % % % % %
\chapter{Simulazione di BRS}\label{cap:simulazione_brs}
Si immagini di avere un sistema che si vuole rappresentare usando il formalismo dei bigrafi. Si immagini di aver definito (su carta) un'adeguata segnatura, un bigrafo rappresentante lo stato iniziale, e un insieme adeguato di regole di riscrittura. Si vuole ora costruire un programma che permetta di \emph{simulare} l'evoluzione del sistema definito sopra. In questo capitolo si descrive un'implementazione di un simulatore e delle sue componenti ancillari.

\begin{term}[Sistema, stato]
D'ora in avanti con il termine \emph{sistema} si intende un sistema reattivo bigrafico (BRS), mentre con \emph{stato} si intende un bigrafo. % che rappresenta uno stato di un sistema.
\end{term}

\paragraph{Traccia della discussione}
Innanzitutto bisogna implementare la segnatura, i bigrafi e le regole: per questo ci si appoggia alla libreria JLibBig.
Poi si pone il problema di come far evolvere il sistema, dato che le regole di riscrittura vengono applicate in modo non-deterministico: non esiste un solo percorso lineare di evoluzione, bensì ve ne sono molteplici, alcuni dei quali magari non hanno senso concretamente; possono addirittura formarsi cicli nell'evoluzione degli stati (p.e. reazioni $A\to B$ e $B\to A$), portando un eventuale processo di simulazione a non terminare. In buona sostanza, può risultare necessario \dquote{filtrare} le applicazioni delle regole di reazione e tenere traccia di di tutti gli stati generati, in modo da poter decidere in seguito quali ci interessano e quali no.
\paragraph{Modularità}
Si può già intuire che un un simulatore è un costrutto complesso: al fine di semplificarne la comprensione, nonché l'implementazione, si propone di suddividerlo in moduli, che verranno discussi uno ad uno. Saranno altresì discusse le basi implementative necessarie.

\section{La libreria JLibBig}\label{sec:jlibbig}
JLibBig è una libreria Java per modellare i bigrafi, reperibile \href{http://mads.uniud.it/}{dal sito del MADS} (laboratorio di Modelli ed Applicazioni di Sistemi Distribuiti) dell'Università di Udine.\footnote{\url{http://mads.uniud.it/}} Essa fornisce la base solida su cui si appoggia la parte implementativa di questo lavoro di tesi. Un breve elenco delle \emph{feature} più utili:
\begin{itemize}
\item Permette di modellare segnature e controlli;
\item Permette di modellare bigrafi ed entità associate (nodi, punti, link, \dots);
\item Permette di agganciare delle proprietà (ovvero coppie $(chiave,valore)$ ) ai nodi dei bigrafi;
\item Implementa le regole di riscrittura e il relativo matching.
\end{itemize}
\paragraph{Cosa non fornisce} La libreria non dà strumenti per efficaci per visualizzare i bigrafi (trattati nel capitolo \vref{cap:visualizzare_bigrafi}) e gestire l'evoluzione di un sistema reattivo bigrafico nel suo insieme: in particolare non permette di tenere traccia di tutti gli stati generati. Ci si propone quindi di costruire delle classi che rendano la simulazione dei BRS un'operazione di alto livello, cioè non rendendo necessario occuparsi dei dettagli implementativi che essa comporta.

\section{Rappresentare Controlli e Segnature}
Le segnature possono essere facilmente costruite utilizzando la classe \emph{factory} \texttt{SignatureBuilder}, a cui si aggiungono i controlli indicandone nome, stato(attivo/passivo) ed arietà con il metodo \texttt{add(String,boolean,int)}.

\addlisting{lst/car_signature.txt}{{[Esempio di definizione di segnatura in JLibBig per il bigrafo \ref{fig:esempio_bigraph_builder}]Esempio di definizione di segnatura in JLibBig per il bigrafo \vref{fig:esempio_bigraph_builder}}}

\section{Rappresentare i Bigrafi}\label{sec:rappresentare_bigrafi}
JLibBig fornisce la classe \texttt{Bigraph}, che permette di definire i bigrafi aggiungendo i vari elementi ad un \texttt{BigraphBuilder}, ovvero una \emph{classe factory}. Nella libreria i bigrafi sono oggetti immutabili: quindi, ogni volta che vengono modificati dall'applicazione delle regole di riscrittura, in realtà viene generato un nuovo oggetto.

\paragraph{Proprietà} Come anticipato, la libreria permette anche di assegnare ai nodi dei bigrafi delle proprietà, cioè coppie nome-valore; per esempio, si può assegnare dei nomi ai nodi. Questo permette anche di rappresentare informazioni che altrimenti andrebbero codificate nei bigrafi stessi con dei controlli appositi. Tuttavia, quando si applicano le regole di riscrittura, tali proprietà non vengono propagate automaticamente.

\addlisting{lst/car_bigraphBuilder.txt}{{[Codifica in JLibBig del bigrafo \ref{fig:esempio_bigraph_builder}]Codifica in JLibBig del bigrafo \vref{fig:esempio_bigraph_builder}}}

\begin{figure*}[h]
\begin{center}
\def \svgwidth{0.9 \textwidth} \input{img/car_example.pdf_tex}
\end{center}
\caption[Esempio di bigrafo (dalla sez. \ref{sec:viaggio_macchina}).]{Esempio di bigrafo (si veda la sez. \vref{sec:viaggio_macchina}).}
\label{fig:esempio_bigraph_builder}
\end{figure*} 

\section{Rappresentare le Regole di Riscrittura}
Anche le regole di riscrittura sono già pronte all'uso in JLibBig, grazie alla classe \texttt{RewritingRule}: si definiscono \emph{redex} e \emph{reactum}, la mappa d'istanziazione e, successivamente, si può applicare la regola chiamando \texttt{apply(Bigraph)}. Così facendo, si ottiene un \texttt{Iterable<Bigraph>}, ovvero una sequenza di bigrafi creati dalle possibili applicazioni della regola.

\addlisting{lst/car_rewritingRule.txt}{{[Codifica in JLibBig della regola di riscrittura \ref{fig:esempio_regola_riscrittura}]Codifica in JLibBig della regola di riscrittura \vref{fig:esempio_regola_riscrittura}}}

\begin{figure}[h]
\begin{center}
\def \svgwidth{\textwidth}
\input{img/car_rr_move.pdf_tex}
\end{center}
\caption[Regola di riscrittura dall'esempio \ref{sec:viaggio_macchina}.]{Regola di riscrittura dall'esempio \vref{sec:viaggio_macchina}.}
\label{fig:esempio_regola_riscrittura}
\end{figure}

\paragraph{Matcher} Per trovare le occorrenze del \emph{redex} in un bigrafo si fa affidamento alla classe \texttt{Matcher}, che modella il problema in un \emph{embedding} (un problema di flusso), e lo risolve con tecniche di programmazione a vincoli (appoggiandosi alla libreria \href{http://choco-solver.org/}{\emph{CHOCO Solver}}).\footnote{\url{http://choco-solver.org/}} % Aggiungere qualcosa su embedding? - link a CHOCO

% paragrafo su RewRuleWProps

\section{Modellare il BRS}
Per modellare il BRS viene fornita l'omonima classe, che ha un semplice compito: essa incapsula le regole di riscrittura del sistema e la ``strategia" con cui esse vengono applicate; passando un bigrafo al BRS, si ottiene la lista degli stati ottenuti applicandovi le regole.

%Si tenga conto che ogni regola può essere applicata più volte, in quanto il \emph{redex} può avere più di un match: questo significa che, anche con poche regole di riscrittura, lo stato del sistema può ramificarsi significativamente.
\paragraph{Implementazione} Nello specifico, BRS produce una lista di \texttt{Bigraph}(s) o, in alternativa, di coppie $\langle \texttt{Bigraph},\texttt{RewritingRule}\rangle$ dette \texttt{RuleApplication}(s), in modo che gli altri moduli del simulatore possano capire che regola ha prodotto una data evoluzione del sistema. Ciò si ottiene chiamando, rispettivamente, i metodi \texttt{apply(Bigraph)} o \texttt{apply\_RA(Bigraph)} (dove \emph{``RA"} sta per \texttt{RuleApplication}).
\paragraph{Strategie} Il modulo BRS è stato implementato in modo da poter definire con che criterio vengono applicate le regole di reazione: per esempio, è possibile definire delle regole di riscrittura con priorità, in modo da controllare l'ordine di applicazione, oppure usare un sistema probabilistico. L'implementazione standard \texttt{BreadthFirstBRS} usa una strategia stile \emph{``breadth first"}, cioè applica le regole nell'ordine in cui sono date, esplorando gli stati successivi del sistema ``in ampiezza". Esiste poi \texttt{RandomBRS} che ritorna una singola applicazione (in particolare la $i$-esima tra tutte le applicazioni, dove $i$ è determinato \emph{pseudo}casualmente).

\begin{figure}[h]
\begin{center}
\subfloat[Applicazione di \texttt{BreadthFirstBRS}]{\input{img/breadth_first_brs.pdf_tex}}
\subfloat[Applicazione di \texttt{RandomBRS}]{\input{img/random_brs.pdf_tex}}
\end{center}
\caption{Strategie di \texttt{BRS} a confronto.}
\end{figure}

\section{Grafo degli stati}
Com'è noto, dato uno stato del sistema (un bigrafo), in generale è possibile applicarvi più di una regola di riscrittura (non-deterministicamente); inoltre, una regola può essere applicata tante volte quanti sono i \emph{match} del redex, generando evoluzioni potenzialmente diverse del sistema.
Per questo motivo si propone di costruire un \emph{grafo degli stati}, che è un grafo orientato in cui:
\begin{itemize}
\item i nodi rappresentano stati del sistema, cioè bigrafi;
\item gli archi indicano le transizioni da uno stato al successivo, e la regola che l'ha prodotta.
\end{itemize}
Questa struttura dati permette di analizzare tutta la storia dell'evoluzione del sistema, e persino di generare tutti gli stati possibili (cosa che può essere sfruttata nel verificare proprietà del sistema, si veda il capitolo \vref{cap:model_checking}).

\begin{figure}[h]
\includegraphics[width=\textwidth]{car_stateGraph.pdf}
\caption[Esempio di grafo degli stati generati a partire dal bigrafo \ref{fig:esempio_bigraph_builder}]{Esempio di grafo degli stati generati a partire dal bigrafo \vref{fig:esempio_bigraph_builder}.}
\label{fig:state_graph}
\end{figure}

\subsection{Problematiche da affrontare} 
Ovviamente costruire, mantenere ed utilizzare una struttura del genere non è privo di criticità. In particolare: 
\begin{itemize}
\item[1] \emph{Se si vuole tener traccia di tutti gli stati possibili, come si fa a capire quando sono stati tutti computati?}

Capire se sono stati generati tutti gli stati possibili è un compito che verrà delegato al simulatore, e comunque non sarà sempre possibile ottenere una risposta: per esempio, se si impiega \texttt{RandomBRS}, sarà impossibile dire quando sono stati ottenuti tutti gli stati.
\item[2] \emph{Se l'applicazione di alcune regole causa cicli nel grafo, come li si gestisce?}

Per quanto riguarda i cicli, prima di gestirli è necessario innanzitutto riconoscerli: per far ciò, ogni qualvolta viene computato un nuovo stato $S$ a partire da uno $T$, prima di aggiungerlo al grafo si controllerà se ne è già presente uno \emph{isomorfo} $S'$; in caso affermativo, invece di aggiungere $S$, si crea un arco da $T$ a $S'$, che può potenzialmente formare un ciclo. Nella figura \vref{fig:state_graph} si può notare come gli stessi stati possano essere generati in più modi. Determinare se due bigrafi sono isomorfi è un altro problema non banale.
\end{itemize}

\subsection{Implementazione} Il grafo degli stati è implementato dalla classe \texttt{BigStateGraph}, i nodi da \texttt{BSGNode} e gli archi da \texttt{BSGLink} (dove \emph{``BSG"} sta per \texttt{BigStateGraph}). I \texttt{BSGNode}(s) sono coppie \texttt{$\langle$Bigraph,[BSGLink]$\rangle$}; I \texttt{BSGLink}(s) sono coppie \texttt{$\langle$BSGNode,RewritingRule$\rangle$}. Il grafo viene inizializzato con un singolo nodo, che rappresenta lo stato iniziale del sistema. I nodi sono mantenuti in una tabella di hash con chaining; la funzione di hash viene fornita dall'interfaccia \texttt{BigHashFunction}, la cui implementazione standard (\texttt{PlaceLinkHash}) genera un numero intero in base alla struttura del \emph{place graph} e \emph{link graph} del bigrafo.
Per aggiungere un nodo si usa il metodo \texttt{applyRewritingRule(BSGNode node, RewritingRule rule, Bigraph state)}, che aggiunge un nuovo nodo figlio di \texttt{node}, con stato \texttt{state}, prodotto applicando la regola \texttt{rule} a \texttt{node}.
Per verificare se ci sono nodi duplicati si svolge una ricerca in due fasi:
\begin{itemize}
\item Si verifica se c'è una collisione nella tabella di hash tra il nodo che si vuole aggiungere ed uno esistente;
\item Se è così, si controlla se i due stati sono isomorfi sfruttando la classe \texttt{Isomorphism}, ed in particolare il suo metodo \texttt{areIsomorph(Bigraph,Bigraph)}.
\item Se sono isomorfi il nuovo stato non viene aggiunto, ma viene inserito un arco ``marchiato" come potenziale creatore di cicli; altrimenti viene aggiunto il nuovo nodo dove opportuno.
\end{itemize}
\paragraph{Isomorfismi tra bigrafi}L'implementazione della classe \texttt{Isomorphism} è un argomento interessante ma corposo, che merita una discussione a parte; ci si limita a specificare che essa modella il problema dell'isomorfismo tra bigrafi come un'eguaglianza di flusso, risolto con tecniche di programmazione a vincoli. Per un'analisi dettagliata si rimanda il lettore a \cite{Geatti:tesiBRS}.


\section{Comporre il Simulatore}
A questo punto si dispone di tutti i moduli necessari a costruire un simulatore di sistemi bigrafici:
\begin{itemize}
\item JLibBig permette di rappresentare bigrafi e regole di riscrittura;
\item \texttt{BRS} permette di gestire l'applicazione delle regole come si ritiene opportuno;
\item \texttt{BigStateGraph} permette tenere traccia dell'evoluzione del sistema e di ``ramificare" la simulazione in più percorsi;
\end{itemize}
Si definisce pertanto il modulo \texttt{Sim}, che sfrutta entrambi in maniera trasparente, fornendo un'interfaccia di più alto livello per simulare sistemi bigrafici. \`E definito come un'\emph{interfaccia} che fornisce la API di base, e che va implementata in base alle necessità dell'utente (come \texttt{BRS}). In particolare tale API prevede la possibilità di fare un ``passo" avanti nella simulazione (cioè applicare le regole ad uno o più stati raggiunti in base alle logiche definite dal programmatore) con \texttt{step()}, di sapere se sono stati esplorati tutti gli stati possibili del sistema con \texttt{simOver()}, o simulare l'evoluzione finché non si raggiunge un limite massimo di passi, o finché non si computano tutti gli stati, con \texttt{fullSim(int max)}.
Di seguito vengono descritte alcune implementazioni già definite di \texttt{Sim}.
\subsection{BreadthFirstSim}
\texttt{BreadthFirstSim} è un simulatore che segue una logica \emph{``breadth-first"}, ovvero ad ogni passo applica tutte le regole del BRS (anch'esso con strategia \emph{breadth-first}) a tutti i nodi ``foglia" (in senso lato) del grafo. Per far ciò mantiene una coda, in cui inizialmente è presente solo lo stato iniziale; una volta applicate le regole a tale stato, mette gli stati generati in fondo alla coda; ciò viene ripetuto per ogni nodo nella coda, finché essa rimane vuota: a questo punto tutti gli stati possibili sono stati generati.

\subsection{RandomSim}
\texttt{RandomSim} è un simulatore che segue un singolo ``ramo" di evoluzione del sistema alla volta: opera in modo uguale a \texttt{BreadthFirstSim}, eccetto per il fatto che, ad ogni passo, sceglie pseudo-casualmente uno stato tra quelli generati e lo sposta al primo posto della coda. In tal modo, pur seguendo un percorso di evoluzione (pseudo)casuale, si tiene traccia degli altri percorsi possibili che si possono proseguire in seguito, permettendo di generare tutti gli stati.

\subsection{TrueRandomSim} 
\texttt{TrueRandomSim} è un simulatore che segue un singolo ``ramo" di evoluzione del sistema: per far ciò, ogni volta che vengono generati degli stati applicando le regole di riscrittura, ne viene scelto uno \emph{pseudo}-casualmente e gli altri vengono scartati; in tal modo, il grafo degli stati si riduce ad una catena lineare di nodi con un solo figlio (eccetto l'ultimo nodo). Si appoggia a \texttt{RandomBRS}. Non è possibile sapere quando si sono esplorati tutti gli stati possibili.

\paragraph{Esempi d'uso} Alcuni esempi dell'impiego del simulatore sono esposti nel capitolo \vref{cap:esempi_applicazioni}.

\chapter{Model Checking}\label{cap:model_checking}
Per \emph{model checking} si intende la verifica di proprietà in sistemi reattivi bigrafici. Avere a disposizione un model checker vuol dire poter verificare se si presentano deteminate situazioni nel sistema, come stati interessanti o stati non validi. Potendosi appoggiare a un simulatore in grado di generare tutti gli stati possibili di un sistema, verificarne una proprietà si riduce a verificarla su tutti gli stati generati. Si può già, quindi, intuire che da simulatore a model checker il passo è (concettualmente) breve.
In questo capitolo si descriverà sinteticamente l'implementazione di un model checker in grado di verificare alcune proprietà sui BRS. L'argomento è trattato più in dettaglio in \cite{Geatti:tesiBRS}.

\section{Predicati}
Innanzitutto è necessario definire un modo di rappresentare le proprietà da verificare. Per far ciò sono stati definiti dei predicati \emph{ad-hoc}, basati sull'interfaccia \texttt{Predicate}, qui elencati:
\begin{itemize}
\item \texttt{TruePredicate} rappresenta la verità;
\item \texttt{AndPredicate} rappresenta l'\emph{and} logico fra due predicati;
\item \texttt{NotPredicate} rappresenta la negazione di un predicato;
\item \texttt{IsoPredicate} rappresenta la relazione \dquote{\emph{è isomorfo a}} tra due bigrafi;
\item \texttt{WarioPredicate}
\footnote{Il nome è nato come un modo simpatico di chiamare quello che altrimenti sarebbe stato il \texttt{WPredicate}, dove la $W$ in realtà è la $M$ di \dquote{match} ruotata di $180°$.}
 è un predicato sui \emph{match} che, dati due bigrafi $F$ e $G$ e tre predicati $\phi_i$ ($i=0,1,2$) è definito come
\begin{center}
$G \models \rotatebox[]{180}{M}_F \iff \exists C,D$ t.c. $G=C\circ (F\otimes id_I)\circ D \wedge (C\models \phi_0 \wedge F\models\phi_1\wedge D\models\phi_2)$
\end{center}
\end{itemize}
Questo insieme di predicati risulta sufficiente a descrivere alcune proprietà interessanti.

\section{Model Checker}
La classe \texttt{ModelChecker} non fa altro che usare un simulatore (il default è \texttt{BreadthFirstSim}) per ottenere le evoluzioni di un sistema, verificando la soddisfazione di un predicato su ogni stato computato. Se esiste uno stato per cui il predicato è soddisfatto, la simulazione termina e la proprietà è verificata. Il model checker ha un tetto massimo (modificabile) di passi di simulazione, in modo da evitare la non-terminazione qualora si impieghino simulatori che sanno quando hanno generato tutti gli stati (come \texttt{TrueRandomSim}). Degli esempi d'uso verranno illustrati nel prossimo capitolo.

\chapter{Esempi e applicazioni}\label{cap:esempi_applicazioni}
In questo capitolo verranno proposti vari esempi per cui si definirà segnatura, stato iniziale, BRS ed eventualmente proprietà da verificare.

\section{Viaggio in macchina}\label{sec:viaggio_macchina}
Si vuole rappresentare un'automobile con una scorta di carburante limitata, che deve raggiungere una locazione prestabilita.
\subsection{Segnatura}
La segnatura è così definita:
\begin{itemize}
\item Il controllo \emph{car} rappresenta l'automobile, e ha una porta che si collega alla sua destinazione;
\item \emph{fuel} rappresenta un'unità di carburante;
\item \emph{place} rappresenta una località verso cui l'auto può spostarsi, se c'è una strada collegata alla sua porta;
\item \emph{road} rappresenta una strada che collega una località ad un'altra;
\item \emph{target} indica la destinazione dell'auto.
\end{itemize}
\addlisting{lst/car_signature.txt}{{[Segnatura dell'esempio \ref{sec:viaggio_macchina}]Segnatura del \dquote{Viaggio in macchina}}}
\begin{figure}[h]
\begin{center}
%\def \svgwidth{\textwidth}
\input{img/car_example.pdf_tex}
\end{center}
\caption[Esempio di stato iniziale per l'esempio \ref{sec:viaggio_macchina}]{Esempio di stato iniziale.}
\end{figure}

\subsection{Regole di riscrittura}
Questo semplice esempio ha una sola regola di riscrittura, chiamata \texttt{RR\_Move}, che permette all'auto di muoversi \dquote{alla cieca}, ovvero senza necessariamente avvicinarsi alla sua destinazione (figura \vref{fig:rr_move}).
\begin{oss}
Con questa sola regola le strade sono effettivamente a senso unico: per renderle a doppio senso di marcia si può aggiungere una seconda strada in senso opposto (per ogni strada), oppure aggiungere una seconda regola duale a \texttt{RR\_Move}.
\end{oss}

\subsection{Verifica di proprietà}
Una proprietà che si presta ad essere verificata è la raggiungibilità della destinazione: esiste uno stato in cui l'auto ha raggiunto il suo obiettivo? Un semplice test viene preparato nel codice \vref{lst:car_model_check}; viene definito il bigrafo $B$ (in figura \vref{fig:car_goal}) che rappresenta il raggiungimento della destinazione; al \texttt{ModelChecker} viene passato un predicato $\rotatebox[]{180}{M}_B$ che è soddisfatto se $B$ ha un match nello stato del sistema.

\begin{figure}[h]
\begin{center}
\def \svgwidth{\textwidth}
\input{img/car_rr_move.pdf_tex}
\end{center}
\caption{Regola \texttt{RR\_Move}.}
\label{fig:rr_move}
\end{figure}

\begin{figure}[b]
\begin{center}
\includegraphics{car_goal.pdf}
\end{center}
\caption[Bigrafo obiettivo per la verifica della raggiungibilità (esempio \ref{sec:viaggio_macchina})]{Bigrafo obiettivo per la verifica della raggiungibilità.}
\label{fig:car_goal}
\end{figure}

\lstinputlisting[numbers=left,float=h,label=lst:car_model_check,breaklines,frame=TB,caption={[Verifica di raggiungibilità nell'esempio \ref{sec:viaggio_macchina}]Verifica della raggiungibilità.}]{lst/car_modelCheck.txt}

\lstinputlisting[numbers=left,float=h,label=lst:car_goal,breaklines,frame=TB,caption={[Definizione del bigrafo obiettivo per l'esempio \ref{sec:viaggio_macchina}]Definizione del bigrafo obiettivo (figura \vref{fig:car_goal})}]{lst/car_goal.txt}
% altro...
\chapter{Conclusioni}

\backmatter
% Bibliografia
\cleardoublepage
%\phantomsection
\addcontentsline{toc}{chapter}{\bibname}
\printbibliography
\printindex
\end{document}