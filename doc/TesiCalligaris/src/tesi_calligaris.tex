%
% PREAMBOLO
%
\RequirePackage[l2tabu, orthodox]{nag} % Pacchetto nag per controllo errori sorgente
\documentclass[11pt,UdineBachThesis,italian]{PhdThesis}  % laurea triennale

\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage[autostyle,italian=guillemets]{csquotes} % necessario per biblatex
\usepackage[bibstyle=numeric,citestyle=numeric,backend=biber]{biblatex} % bibliografia
\usepackage{microtype} % tipografia
\usepackage{graphicx} % immagini
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{subfig} % sottofigure
\usepackage{lipsum} % lorem ipsum
\usepackage{listings} % codice
\usepackage{float}
\usepackage{hyperref} % questo va per ultimo

% Teoremi
\newtheorem*{nota}{Notazione}
\newtheorem*{dimo}{Dimostrazione}

\theoremstyle{definition}
\newtheorem{teo}{Teorema}
\newtheorem{prop}{Proposizione}
\newtheorem{cor}{Corollario}
\newtheorem{defi}{Definizione}
\newtheorem*{term}{Terminologia}

\theoremstyle{remark}
\newtheorem*{oss}{Osservazione}
\newtheorem*{esempio}{Esempio}

% Comandi aggiuntivi
\newcommand{\eqdef}{\stackrel{\text{\tiny def}}{=}} % equal con def sopra
\newcommand{\squote}[1]{\textquoteleft#1\textquoteright} % testo tra singlequote
\newcommand{\dquote}[1]{\textquotedblleft#1\textquotedblright} % testo tra doublequote

% Traduzioni
%\newtranslation[to=italian]{Section}{Sezione}
% Direttive
\renewcommand{\lstlistingname}{Codice}
\lstset{basicstyle=\small\ttfamily}
\setlength{\parindent}{0pt} % togliere indentazione paragrafi
\graphicspath{{img/}}
\addbibresource{bib/milner_1540607.bib} % bibliografia
\addbibresource{bib/geatti_tesi_brs.bib} % bibliografia
\makeindex

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%			INIZIO DOC
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\title{Simulazione di Sistemi Reattivi Bigrafici}
\author{Elia Calligaris}
%\email{eliacmail@libero.it}
\supervisor{Prof. Marino Miculan}
\cosupervisor{Dott. Marco Peressotti}
\date{2014-2015}

\begin{document}
\pagestyle{empty}
\maketitle
\partstyle{serifbig}
\chaptertitlestyle{serifbig}
\pagestyle{serif}
\frontmatter
\begin{dedication}
\emph{A coloro che mi hanno donato la parola,\newline ed a coloro che mi hanno insegnato ad usarla.}
\end{dedication}

\tableofcontents
\listoffigures
\lstlistoflistings

%\chapter*{Prefazione}
%\addcontentsline{toc}{chapter}{Prefazione}
%\lipsum

\mainmatter
\chapter{Introduzione}
%\pagestyle{empty}
%\addcontentsline{toc}{chapter}{Introduzione}

\chapter{Teoria dei bigrafi}\label{cap:teoria}
\pagestyle{plain}
% spostare sta roba
In questo capitolo si daranno definizioni formali dei bigrafi, delle loro componenti, e delle relative operazioni elementari e derivate; si vedrà come costruire un bigrafo a partire da bigrafi elementari, e si darà la definizione di \emph{BRS} (\emph{Sistema Reattivo Bigrafico}).

La teoria è estratta dall'ampia trattazione di Robert Milner \cite{Milner:SMCA}, e adattata per le ridotte necessità di questa tesi.

\section{Bigrafi e le loro componenti}\label{sec:componenti_bigrafi}

Un \emph{bigrafo} è un tipo particolare di grafo in cui i nodi possono essere annidati l'uno dentro l'altro, e gli archi sono \emph{iper-archi}, cioè collegano un punto di partenza a più punti di arrivo. Pertanto, come la parola \emph{bi-grafo} suggerisce, siamo in presenza di una struttura composta da due grafi indipendenti, dei quali uno descrive la topologia, e l'altro i collegamenti tra nodi.
Inoltre si possono definire diversi tipi di nodo con diverso significato: questo rende i bigrafi un \emph{meta-modello}, in modo simile all'XML. 

\begin{figure}[h]
\begin{center}
%\def \svgwidth{ 2 \textwidth / 3}
%\input{img/big_esempio_nonomi.pdf_tex}
\includegraphics[width=2 \textwidth /3]{big_esempio_nonomi.pdf}
\end{center}
\caption{Esempio di bigrafo.}
\end{figure}

\subsection{Segnature e controlli}\label{ssec:segnature}

Data la generalità dei bigrafi, è innanzitutto necessario definire il significato dei nodi: per far ciò gli si assegnano dei \emph{controlli}.
\begin{defi}[Controllo]
Un \emph{controllo} $K$ è il tipo di un nodo.
\end{defi}
Ogni nodo ha un solo controllo, ed ogni controllo è tipicamente definito con un nome. La possibilità di creare ed assegnare controlli ai nodi permette di definirne il significato a piacere, garantendo una grande libertà semantica. Per fare un paragone con la programmazione orientata agli oggetti, un nodo sta al suo controllo come un'istanza sta alla sua classe.
\begin{term}[K-nodo]
Con l'espressione \emph{K-nodo} si intende un nodo il cui controllo è $K$.
\end{term}
Ora, siccome ogni bigrafo avrà (tipicamente) più di un tipo di nodo, è necessario definirne l'insieme dei controlli.
\begin{defi}[Segnatura]
Una \emph{segnatura} è una coppia $(K,ar)$, dove $K$ è un insieme di controlli e $ar$ è una funzione $K\rightarrow \mathbb{N} $, che mappa ad ogni nodo la sua arietà (numero di porte).
\end{defi}

\begin{oss}
Tramite la segnatura, si accoppia il controllo di un nodo al suo numero di porte biunivocamente.
\end{oss}

\begin{nota}
Per semplicità, le segnature possono essere descritte come segue:
\begin{center}
$K = \{ K_1:a_1, \dots, K_n:a_n \}$ intendendo che il controllo $K_i$ ha arietà $a_i$.
\end{center}
\end{nota}

Quindi tramite la segnatura si ha già una prima caratterizzazione del bigrafo in termini di semantica ed arietà dei nodi. Con questo fondamento si può passare ad analizzare la topologia e le relazioni tra nodi.

\subsection{\foreignlanguage{english}{Place graph}}\label{ssec:place_graph}
Il place graph è una foresta che descrive la topologia del bigrafo; in altre parole, indica come sono annidati i nodi. Ogni albero della foresta inizia con una \emph{radice} (o \emph{regione}); ogni radice è etichettata con un numero che va da $0$ a $n-1$, dove $n$ è il numero di radici.
Ogni nodo può contenere un \emph{sito}, che indica la possibilità che vi siano altri nodi all'interno di quel nodo.

\begin{figure}[t]
\begin{center}
\subfloat[Bigrafo]{\includegraphics{big_esempio_nonomi.pdf}}\qquad
\subfloat[Place graph]{\includegraphics{place_esempio.pdf}}
\end{center}
\caption{Esempio di bigrafo e relativo place graph.}
\end{figure}

\begin{term}[Posto]
Gli elementi del place graph sono detti \emph{posti}.
\end{term}

\begin{nota}
Con $A\uplus B$ si intende l'unione di insiemi che si sa o si assume essere fra loro disgiunti.
\end{nota}

\begin{defi}[Place graph]
Un \emph{place graph} è una tripla $(V,ctrl,prnt):m\rightarrow n$ dove:
\begin{itemize}
\item $V$ è l'insieme dei nodi;
\item $ctrl$ è la mappa $V\rightarrow K$ che assegna ad ogni nodo un controllo;
\item $m$ è l'\emph{interfaccia interna} ed $n$ l'\emph{interfaccia esterna}; rappresentano rispettivamente il numero di siti e di radici, pertanto sono entrambe rappresentate da numeri finiti;
\item $prnt$ è la mappa (aciclica) $m \uplus V \rightarrow V \uplus n$, che assegna ad ogni nodo il suo genitore (se c'è).
\end{itemize}
\end{defi}

\subsection{Link graph}\label{ssec:link_graph}
Il link graph è un \emph{ipergrafo} (cioè un grafo i cui archi possono connettere più nodi) non orientato che descrive il collegamento fra i vari nodi del bigrafo (ovvero le loro relazioni). Il link graph descrive anche dei potenziali collegamenti con altri bigrafi grazie alle interfacce descritte dagli \emph{inner names} e dagli \emph{outer names}: gli outer names indicano l'interfaccia verso l'esterno, a cui possono collegarsi altri bigrafi; gli inner names (interfaccia interna) descrivono l'interfaccia dei bigrafi che possono aggiunti per composizione (si veda il paragrafo \ref{ssec:op_costruzione}). 

\begin{figure}[ht]
\begin{center}
\subfloat[Bigrafo]{\setlength\fboxsep{10pt}
\fbox{\input{img/big_esempio_nomi.pdf_tex}}}\qquad
\subfloat[Link graph]{ \setlength\fboxsep{10pt}
\fbox{\input{img/link_esempio.pdf_tex}}}
\end{center}
\caption{Esempio di bigrafo e relativo link graph.}
\end{figure}

\begin{term}[Punti e link] \foreignlanguage{english}{Inner names} e porte vengono chiamati \emph{punti}; \foreignlanguage{english}{outer names} e archi vengono chiamati \emph{link}. Gli archi sono detti \emph{link chiusi}, mentre gli outer names sono detti \emph{link aperti}.
\end{term}

\begin{defi}
Un link graph è una tupla $(V,E,ctrl,link):X\rightarrow Y$ dove:
\begin{itemize}
\item $V$ ed $E$ sono, rispettivamente, gli insiemi (finiti) dei nodi e degli (iper)archi;
\item $ctrl$ è la mappa dei controlli $V\rightarrow K$;
\item $X$ e $Y$ sono, rispettivamente, le \emph{interfacce interna} e \emph{esterna}, composte dagli \emph{\foreignlanguage{english}{inner names}} e dagli \emph{\foreignlanguage{english}{outer names}};
\item $link$ è la mappa $X \uplus P \rightarrow E \uplus Y$, dove $P = \{(v,i) : v \in V, i \in ar(ctrl(v)) \}$ è l'insieme delle porte.
\end{itemize}
\end{defi}

\begin{term}[Idle]
Un posto senza figli o un link senza punti è detto \emph{idle}.
\end{term}

\subsection{Bigrafo}\label{ssec:bigrafo}
Definendo le strutture che compongono i bigrafi, si è parlato più volte di \emph{interfacce}. Ora verranno definite formalmente.
\begin{defi}[Interfaccia]
Un'\emph{interfaccia} per bigrafi è una coppia $\langle m,X\rangle$, dove $m \in \mathbb{N}$ è detta \emph{larghezza}, mentre $X$ è l'insieme dei nomi.
\end{defi}

Detto questo, si può dare una definizione formale di bigrafo.

\begin{defi}[Bigrafo]
Un \emph{bigrafo} è una tupla 
\begin{center}
$(V,E,ctrl,prnt,link):\langle m,X\rangle \rightarrow \langle n,Y\rangle$
\end{center}
dove $\langle m,X\rangle$ è detta \emph{interfaccia interna}, mentre $\langle n,Y\rangle$ è detta \emph{interfaccia esterna}.
\end{defi}
\begin{oss}
Un bigrafo $B$ è composto da:
\begin{itemize}
\item un place graph $B^P=(V,ctrl,prnt):m\rightarrow n$;
\item un link graph $B^L=(V,E,ctrl,link):X\rightarrow Y$.
\end{itemize}
Che sono strutture ortogonali ed indipendenti. Pertanto, un bigrafo si può definire anche come una coppia $\langle B^P,B^L\rangle$.
\end{oss}

\begin{figure}[ht]
\begin{center}
\subfloat[Bigrafo $B$]{\setlength\fboxsep{10pt}
\fbox{\input{img/big_esempio_nomi2.pdf_tex}}}\qquad
\subfloat[Place graph $B^P$]{\setlength\fboxsep{10pt}
\fbox{\includegraphics{place_esempio.pdf}}}
\subfloat[Link graph $B^L$]{ \setlength\fboxsep{10pt}
\fbox{\input{img/link_esempio.pdf_tex}}}
\end{center}
\caption{Esempio di bigrafo e sua scomposizione.}
\end{figure}

\begin{term}(Ground, agente)
Un bigrafo la cui interfaccia interna è vuota viene detto \emph{ground} o \emph{agente}. Ne viene indicata solo l'interfaccia esterna.
\end{term}

\begin{nota}
I bigrafi generici vengono indicati con lettere maiuscole ($A$,$B$,$C$,\dots), mentre gli agenti vengono indicati con lettere minuscole ($a$,$b$,$c$,\dots).
\end{nota}

\subsection{Sorting?}
% aggiungere sorting?
\lipsum[1]


% % % Operazioni sui bigrafi
\section{Operazioni sui bigrafi}\label{sec:op_bigrafi}
Ora si andranno a definire alcune operazioni sui bigrafi e la loro algebra, con lo scopo di fornire il necessario per poter costruire bigrafi complessi a partire da quelli elementari. Tali operazioni saranno fondamentali anche per poter descrivere l'evoluzione dei sistemi reattivi bigrafi (sez. \ref{sec:evoluzione_bigrafi}).

\subsection{Operazioni di base}\label{ssec:op_base}
\begin{nota}
Con $Id_I$ si indica la funzione identità sull'insieme $I$.
\end{nota}

\begin{defi}[Supporto] % spostare in Bigrafo? anche no
Ad ogni link graph, place graph, o bigrafo $B$ viene assegnato un insieme finito $|B|$ detto \emph{supporto}.
Per un place graph $|B|=V$, mentre per link graphs e bigrafi $|B|=V\uplus E$.
\end{defi}
\begin{defi}[Traduzione di supporto] % biezione? biiezione?
Per due bigrafi $F$ e $G$, una \emph{traduzione di supporto} $\rho: |F|\rightarrow |G|$ è una coppia di biiezioni $\rho_V:V_F\rightarrow V_G$ e $\rho_E:E_F\rightarrow E_G$ che ne rispetta la struttura, ovvero:
\begin{itemize}
\item $\rho$ preserva i controlli, cioè $ctrl_G \circ \rho_V = ctrl_F$; ne consegue che $\rho$ induce una biiezione $\rho_P:P_F \to P_G$ sulle porte, definita da $\rho_P((v,i)) \eqdef (\rho_V(v),i)$. 
\item $\rho$ commuta con le mappe strutturali come segue:
 \subitem per i posti: $prnt_G \circ \left( id_m \uplus \rho_V \right) = \left( id_n \uplus \rho_V \right) \circ prnt_F$
 \subitem per punti e link: $link_G \circ \left( id_X \uplus \rho_P \right) = \left( id_Y \uplus \rho_E \right) \circ link_F$
\end{itemize}
Dati $F$ e la biiezione $\rho$, sotto queste condizioni è possibile determinare univocamente $G$; pertanto si dice che $G=\rho \cdot F$ è la traduzione di supporto di $F$ per $\rho$.
\end{defi}

\begin{defi}[Equivalenza sul supporto]
Diremo che $F$ e $G$ sono \emph{support equivalent} (hanno supporti equivalenti) e si scriverà $F \bumpeq G$,
se e solo se esiste una traduzione di supporto tra $F$ e $G$.
\end{defi}

\subsection{Operazioni di costruzione}\label{ssec:op_costruzione} 
Verranno ora illustrate le principali operazioni di costruzione di bigrafi.

\begin{defi}[Composizione]
Dati due bigrafi con supporti disgiunti
\begin{center}
 $F:\left<m,X\right> \to \left<k,Z\right>$ , $G:\left<k,Z\right> \to \left<n,Y\right>$
\end{center}
la composizione $H = G \circ F : \left<m,X\right> \to \left<n,Y\right>$ è il bigrafo
\begin{center}
 $H = G \circ F = (V_F \uplus V_G , E_F \uplus E_G , ctrl_F \uplus ctrl_G , prnt_H , link_H )$
\end{center}
dove:
\begin{center}
$prnt_H(w) = 
\begin{cases}
 prnt_F(w) & \text{se } w \in m \uplus V_F \wedge prnt_F(w) \in V_F\\
 prnt_G(j) & \text{se } w \in m \uplus V_F \wedge prnt_F(w) = j \in k\\
 prnt_G(w) & \text{se } w \in V_G
\end{cases}$\\
$link_H(q) =
\begin{cases}
 link_F(q) & \text{se } q \in X \uplus P_F \wedge link_F(q) \in E_F\\
 link_G(z) & \text{se } q \in X \uplus P_F \wedge link_F(q) = z \in Z\\
 link_G(q) & \text{se } q \in P_G
\end{cases}$\\
\end{center}
con $P_F$ e $P_G$ insiemi delle porte, come definiti nella sezione del link graph.
\end{defi}

\begin{oss}
La composizione richiede che l'interfaccia esterna di $F$ sia uguale a quella interna di $G$.
\end{oss}

\begin{term}[Contesto]
Un bigrafo composto con un agente viene detto \emph{contesto}.
\end{term}

\begin{defi}[Bigrafo identità]
Il \emph{bigrafo identità} su $\left<m,X\right>$ è \begin{center}
$id_{\left<m,X\right>} = (\emptyset , \emptyset, \emptyset_K , id_m , id_X)$.
\end{center}
\end{defi}

\begin{defi}[Bigrafi disgiunti]
Due bigrafi $F_i:\langle m_i,X_i\rangle \to \langle n_i,Y_i\rangle $ ($i=0,1$) sono \emph{disgiunti} se $|F_i|$,$X_i$ e $Y_i$ sono (rispettivamente) fra loro disgiunti.
\end{defi}

\begin{defi}[Giustapposizione]
Dati due bigrafi disgiunti:
\begin{center}
$F:\left<m_F,X_F\right> \to \left<n_F,Y_F\right>$ , $G:\left<m_G,X_G\right> \to \left<n_G,Y_G\right>$
\end{center}
la loro giustapposizione $F \otimes G:\left<m_F+m_G , X_F \uplus X_G\right> \to \left<n_F+n_G , Y_F \uplus Y_G\right>$ è il bigrafo
\begin{center}
 $F \otimes G = (V_F \uplus V_G ,\ E_F \uplus E_G ,\ ctrl_F \uplus ctrl_G ,\ prnt_F \uplus prnt^\prime_G ,\ link_F \uplus link_G)$
\end{center}
dove $prnt^\prime_G(m_F+i) = n_F + j$ ogni qualvolta $print_G(i) = j$.
\end{defi}

\begin{oss}
Nella giustapposizione tra bigrafi l'interfaccia unità è $\epsilon = \langle 0,\emptyset \rangle$.
\end{oss}

\subsection{Algebra dei bigrafi}\label{sec:algebra_bigrafi}
Ora si mostrerà come i bigrafi possono essere costruiti a partire da bigrafi più piccoli, per via di composizioni, prodotti ed identità.
Verranno descritti i bigrafi elementari e le loro forme normali.

\begin{defi}[Placing, permutazione, merge]
Un \emph{placing} ($\phi$) è un bigrafo senza né nodi né link.
Un placing biiettivo dai siti alle radici (ovvero che per ogni radice ha un solo sito) è una \emph{permutazione} ($\pi$).
Un placing con una radice ed $n$ siti è denotato con $merge_n$.
Vengono definiti tre placing detti \emph{elementari}:
\begin{figure}[h]
\begin{center}
\subfloat{\input{img/placing_elem1.pdf_tex}}\quad
\centering
\subfloat{\input{img/placing_elem2.pdf_tex}}\qquad
\subfloat{\input{img/placing_elem3.pdf_tex}}
\end{center}
\caption{Placing elementari.}
\end{figure}
\end{defi}

\begin{oss}
Tutte le permutazioni possono essere costruite a partire dalla simmetria elementare $\gamma_{1,1}$; tutti i placings possono essere costruiti a partire da $\gamma_{1,1}$, $1$ e $join$.
\end{oss}
\begin{esempio}
$merge_0 = 1$ e $merge_{n+1}= join \circ (id_I \otimes merge_n)$
\end{esempio}

\begin{defi}[Linking, sostituzione, chiusura]
Un \emph{linking} ($\lambda$) è un bigrafo senza posti. I linkings sono generati per composizione, prodotto e identità a partire da \emph{sostituzioni elementari} $y/X$ e \emph{chiusure elementari} $/x:x\to \epsilon$ (si veda la figura \ref{fig:linking_elem}).

Una \emph{sostituzione} ($\sigma$) è il prodotto di sostituzioni elementari; una \emph{chiusura} è il prodotto di chiusure elementari.

La sostituzione vuota è $x:\epsilon \to x$.
\end{defi}
\begin{figure}[h]
\begin{center}
\subfloat[Sostituzione elementare]{\input{img/linking_elem1.pdf_tex}}\qquad
\centering
\subfloat[Chiusura elementare]{\qquad\qquad\input{img/linking_elem2.pdf_tex}}
\end{center}
\caption{Linking elementari.}
\label{fig:linking_elem}
\end{figure}

\begin{term}[Rinomina]
Una sostituzione biiettiva è detta \emph{rinomina} ($\alpha$).
\end{term}

\begin{prop}[Isomorfismo]
Isomorfismi tra place graphs e link graphs sono, rispettivamente, permutazioni $\pi$ e rinomine $\alpha$; isomorfismi tra bigrafi sono coppie $\langle \pi,\alpha \rangle$.
\end{prop}

C'è solo un tipo di bigrafo elementare che introduce nodi: l'\emph{ione}.
\begin{defi}[Ione]
Per ogni controllo $K : n$, il bigrafo 
 $K_{\vec{x}}: 1 \to \left< 1 , \{ x_1 , \ldots , x_n \} \right>$ 
avente un unico nodo $K$ le cui porte sono collegate biiettivamente con $n$ 
distinti nomi ed un unico sito all'interno di $K$, è detto \emph{ione discreto} (o più semplicemente, \emph{ione}).
\begin{figure}[h]
\begin{center}
\def\svgwidth{\textwidth/3}
\input{img/ione.pdf_tex}
\end{center}
\caption{Ione.}
\end{figure}
\end{defi}

\begin{defi}[Primo, discreto]
% controllare traduzione homset
Un bigrafo \emph{primo} con interfaccia $m\to\langle X\rangle$ è privo di inner names, e ha una sola radice. Un bigrafo (o link graph) è \emph{discreto} se non ha link chiusi, e la sua mappa dei link è biiettiva.  
\end{defi}

\begin{oss}
$merge_n:n\to 1$ è un primo importante, in quanto non ha nodi e mappa $n$ siti in una singola radice.
\end{oss}

\begin{defi}[Atomo, molecola]
Se il sito di un K-ione discreto è riempito da $1:0\to 1$ (placing elementare), il risultato è un \emph{atomo} discreto $K_{\vec{x}}\circ 1$; se è riempito da un bigrafo discreto $G: I \to \langle 1,Y\rangle$ è una \emph{molecola} discreta $(K_{\vec{x}} \otimes id_Y)\circ G$. 
\begin{figure}[h]
\begin{center}
\subfloat[Atomo]{\input{img/atomo.pdf_tex}}
\centering
\subfloat[Molecola]{\qquad\input{img/molecola.pdf_tex}}
\end{center}
\caption{Atomo e molecola.}
\end{figure}
\end{defi}

\begin{oss}
L'identità $id_I$ è importante qua: permette ai nodi di $C_1$ di avere figli in $C_2$ ed $F$, e permette a $C_1$ e $C_2$ di condividere link che non coinvolgono $F$.
\end{oss}

\begin{prop}[Forma Normale Discreta]
Ogni bigrafo $G:\left<m,X\right> \to \left<n,Z\right>$
può essere espresso univocamente, a meno di rinomine su $Y$, come
\begin{center}
 $G = (id_n \otimes \lambda) \circ D$
\end{center}
dove $\lambda:Y \to Z$ è un linking e $D:\left<m,X\right> \to \left<n,Y\right>$ è discreto.
Inoltre, ogni bigrafo discreto $D$ può essere fattorizzato univocamente, a meno di permutazione dei siti per ogni fattore, come
\begin{center}
 $D = \alpha \otimes ((P_0 \otimes \cdots \otimes P_{n-1}) \circ \pi)$
\end{center}
con $\alpha$ un renaming, ogni $P_i$ primo e discreto e $\pi$ una permutazione di tutti i siti.
\end{prop}
Si noti che il renaming $\alpha$ è discreto ma non primo, dato che ha $width=0$ e possiede inner names.
Nel caso in cui il grafo $D$ sia ground, il risultato può essere semplificato come segue:
\begin{cor}[Forma Normale Discreta per Bigrafi Ground]
Un bigrafo ground $g:\left<n,Z\right>$ è fattorizzabile in modo univoco, a meno di rinomine su $Y$, come
\begin{center}
 $g=(id_n \otimes \lambda) \circ (d_0 \otimes \cdots \otimes d_{n-1})$
\end{center}
dove $\lambda : Y \to Z$ sono linking e $d_i$ sono bigrafi discreti e primi.
\end{cor}

Questa scomposizione di un bigrafo in bigrafi discreti più piccoli è cruciale per dimostrare la completezza
della teoria algebrica dei bigrafi (\cite{Milner:SMCA}). 

\subsection{Operazioni derivate}\label{ssec:op_derivate}

\begin{nota} 
Spesso si omette \squote{$\cdots \otimes id_I$} in una composizione del tipo
$(F \otimes id_I) \circ G$, dove $F$ non possiede un'interfaccia sufficiente per comporre con $G$. Si scriverà dunque,
qualora non presenti ambiguità, $F \circ G$.
Dato un linking $\lambda : Y \to Z$, potremmo volerlo applicare ad un bigrafo $G$ con interfaccia esterna $\left<m,X\right>$
avente meno nomi, i.e. $Y = X \uplus X^\prime$. Scriveremo allora $\lambda \circ G$ per indicare
$(id_m \otimes \lambda) \circ (G \otimes X^\prime)$, quando $m$ e $X^\prime$ possono essere capiti dal contesto.

Se $X=\{x_1,\dots,x_n\}$ si scriverà $/X$ per intendere $/x_1 \otimes \dots \otimes x_n$.
\end{nota}

\begin{defi}[Prodotto parallelo]
Siano $G_i:\langle m_i,X_i\rangle\to\langle n_i,Y_i\rangle$ ($i=0,1$) due bigrafi i cui supporti sono disgiunti e per cui $link_0\cap link_1$ è una funzione; Allora il loro \emph{prodotto parallelo} %($\parallel$) 
\begin{center}
$G_0\parallel G_1\eqdef\langle m_0+m_1,X_0\cup X_1\rangle\to\langle n_0+n_1,Y_0\cup Y_1\rangle$
\end{center}
è definito proprio come la giustapposizione, eccetto per il fatto che la mappa dei link permette la condivisione dei nomi.
\end{defi}

\begin{prop}[Proprietà di $\parallel$]
Il prodotto parallelo ha la \emph{proprietà associativa}, ovvero $F \parallel ( G \parallel H) = (F \parallel G) \parallel H$, ed ha $id_\epsilon$ come unità; inoltre soddisfa la \emph{proprietà \squote{bifuntoriale}}, se ambo le parti sono definite:
\begin{center}
$(F_1 \parallel G_1) \circ (F_0 \parallel G_0) = (F_1 \circ F_0) \parallel (G_1 \circ G_0)$
\end{center}
\end{prop}
\begin{dimo}
La dimostrazione segue linearmente dalla definizione, una volta notato che la condizione sulle mappe dei link è soddisfatta da una parte se e solo se è soddisfatta anche dall'altra.\qed
\end{dimo}

\begin{defi}[Annidamento]
Dati i bigrafi $F:I\to\langle m,X\rangle$ e $G:m\to\langle n,Y\rangle$, il loro \emph{annidamento} $G.F: I \to \langle m,X\cup Y\rangle$ è definito come:
\begin{center}
$G.F\eqdef (id_X\parallel G)\circ F$
\end{center}
\end{defi}
% exempio milner

\begin{defi}[Prodotto Merge]
Il prodotto merge ($|$) di due bigrafi $G_i:\left<m_i,X_i\right> \to \left<n_i,Y_i\right>$ $(i=0,1)$, il cui prodotto parallelo esiste, è definito come:
\begin{center}
 $G_0 \mid G_1 = merge_{n_0+n_1} \circ ( G_0 \parallel G_1 ): \left< m_0 + m_1 , X_0 \cup X_1\right> \to \left< 1 , Y_0 \cup Y_1\right>$
\end{center}
\end{defi}

\begin{prop}[Proprietà di $\mid$]
Il prodotto merge gode della \emph{proprietà associativa} e (su bigrafi di larghezza unitaria) ha 1 come unità.
\end{prop}

\section{Evoluzione dei bigrafi}\label{sec:evoluzione_bigrafi}
Il uno dei motivi per cui i bigrafi sono un formalismo interessante è la loro capacità di evolvere.

\begin{defi}[Reazione]
Una \emph{reazione} $F\to F'$ è una trasformazione da un bigrafo $F$ ad un bigrafo $F^\prime$.
\end{defi}

\begin{defi}[Segnatura dinamica]
Una segnatura è detta \emph{dinamica} se associa ad ogni controllo $K$ uno \emph{stato} nell'insieme $\{attivo,passivo\}$.
Un K-nodo è detto attivo se il suo controllo è attivo. Le regioni sono sempre attive.
Un sito è attivo se tutti i suoi antenati nel place graph sono attivi. Un bigrafo è attivo se tutti i suoi siti
sono attivi.
\end{defi}

\begin{oss}
Un K-nodo passivo, e conseguentemente tutti i suoi discendenti, sono inibiti al prendere parte alle reazioni.
\end{oss}

Definito cosa intendiamo per reazione, ora è necessario formalizzare un modo per rappresentare il \emph{modo} in cui queste reazioni avvengono; ciò viene ottenuto definendo delle \emph{regole di riscrittura}.

\subsection{Regole di riscrittura}\label{ssec:regole_riscrittura}

\begin{defi}[Regola di riscrittura]\label{def:regola_riscrittura}
Una \emph{regola di riscrittura} $R\to R^\prime$ definisce una reazione $a\to a'$, dove:
\begin{itemize}
\item $a = C\circ (R\otimes id_I)\circ d$;
\item $a'= C\circ (R'\otimes id_I)\circ d$;
\item $C$ è attivo;
\item $a$, $a'$ e $d$ sono \emph{ground}(\emph{agenti});
\item $R$ ed $R'$ hanno una stessa interfaccia $I$.
\end{itemize}
\end{defi}
\begin{term}[Redex, Reactum]
$R$ è detto \emph{redex}, $R'$ è detto \emph{reactum}.
\end{term}

\begin{figure}[h]
\begin{center}
\def \svgwidth{0.8 \textwidth}
\input{img/regola_reazione.pdf_tex}
\end{center}
\caption[Esempio di regola di riscrittura.]{Esempio di regola di riscrittura. A sinistra della freccia c'è il redex, a destra c'è il reactum}
\end{figure}

In buona sostanza, quando si applica una regola di riscrittura ad un bigrafo $B$, si va a cercare un'\emph{occorrenza} del redex in $B$, e la si sostituisce con il reactum. Ora si formalizzerà questo procedimento.

\begin{defi}[Occorrenza]
Un bigrafo $F$ \emph{occorre} in un bigrafo $G$ se l'equazione $C_1 \circ (F \otimes id_I) \circ C_2$ è vera per qualche interfaccia $I$ e bigrafo $C_1$ e $C_2$.
\end{defi}

\begin{term}[Matching, contesto, parametro] La ricerca dell'occorrenza di un bigrafo $F$ in uno $G$ viene detta \emph{matching}. I risultati del matching vengono chiamati \emph{match}, indicati con  $M = C \circ (F \otimes id_I) \circ D$; $C$ viene detto
\emph{contesto} mentre $D$ viene chiamato \emph{vettore di parametri} (o, più semplicemente, \emph{parametro}).
\end{term}

\begin{oss}
Con riferimento alla definizione \ref{def:regola_riscrittura}, il fatto che $R$ ed $R^\prime$ debbano avere la stessa interfaccia è un vincolo molto forte:
infatti non ciò consente di fare, per esempio, la copia del contenuto di un nodo in un altro, o lo scambio
dei contenuti di due nodi in regioni differenti (mantenendo inalterata la loro posizione).
\end{oss}
Per rilassare questo vincolo, si va a definire una mappa tra le interfacce del redex e del reactum.

\begin{defi}[Mappa d'istanziazione]
Siano $R$ ed $R^\prime$ due bigrafi con, rispettivamente, $\left<m,X\right>$ e $\left<m^\prime,X\right>$ come interfacce interne. Una \emph{mappa d'istanziazione} è una funzione
$\eta : m^\prime \to m$ che mappa siti di $R^\prime$ in siti di $R$.
\end{defi}

\begin{defi}[Funzione istanza/istanziamento]
Una \emph{funzione istanza} $\bar{\eta}$, data una mappa d'istanziazione $\eta : m^\prime \to m$, e dato un agente $g:\left<m,X\right>$ la cui Forma Normale Discreta è $g = \lambda \circ ( d_0 \otimes \cdots \otimes d_{m-1} )$, è definita come:
\begin{center}
 $\bar{\eta}(g) \eqdef \lambda \circ ( d^\prime_0 \parallel \cdots \parallel d^\prime_{m^\prime - 1} )$, con $d^\prime_i \bumpeq d_{\eta(i)}$.
\end{center}
\end{defi}

Grazie alle mappe di istanziazione è possibile definire una forma più espressiva di regola di riscrittura.

\begin{defi}[Regola di riscrittura parametrica]
Una regola di riscrittura $R\to R'$, affiancata da una mappa d'istanziazione $\eta$, è detta \emph{regola di riscrittura parametrica}.
Dato un \emph{agente} $a$, dove $R$ occorre in $a$, la regola di riscrittura parametrica produce la seguente reazione $a\to a'$, dove:
\begin{itemize}
\item $a = C \circ (R \otimes id_I) \circ d$;
\item $a' = C \circ (R^\prime \otimes id_I) \circ \bar{\eta}(d)$;
\item $\bar{\eta}$ è la funzione istanza su $\eta$. 
\end{itemize}
\end{defi}

\begin{oss} Ogni regola di riscrittura si può scrivere come una regola di riscrittura parametrica che ha come mappa d'istanziazione la funzione identità.
\end{oss}

\begin{term} In seguito, con la locuzione \emph{regola di riscrittura}, si indicheranno le regole di riscrittura \emph{parametriche}.
\end{term}

\subsection{BRS - Sistema Reattivo Bigrafico}\label{ssec:brs}
Definite le regole di scrittura, si vuole accoppiare la semantica del bigrafo (definita dalla segnatura) all'insieme di regole che ne causano l'evoluzione. Ciò viene fatto dal \emph{BRS}.

\begin{defi}[Sistema Reattivo Bigrafico - BRS]
Un \emph{Sistema Reattivo Bigrafico} (BRS) è definito da una coppia $(K , \mathcal{R})$, dove $K$  è una segnatura ed $\mathcal{R}$ è un insieme di regole
di riscrittura; pertanto viene indicato con $BG(K,\mathcal{R})$.
 L'insieme $\mathcal{R}$ è chiuso rispetto all'\emph{equivalenza sul supporto}: se $R \bumpeq S$ e $R^\prime \bumpeq S^\prime$ e $(R,R^\prime,\eta) \in \mathcal{R}$ per un certo $\eta$, allora $(S,S^\prime,\eta) \in \mathcal{R}$.
\end{defi}

Pertanto, dato un agente $a$ con segnatura $K$, $BG(K,\mathcal{R})$ permette di calcolare tutti gli agenti $a'$ che si possono ottenere facendo reagire $a$ un numero indeterminato di volte, ovvero gli $a':a\to_* a'$.


Nei capitoli a seguire, sarà illustrato un modo di implementare e simulare il BRS, nonché di ottenere tutti gli stati possibili del sistema da esso.

% % % % % % % % % % % % % % % % % % % % % % % 
%			CAP 2							%
% % % % % % % % % % % % % % % % % % % % % % % 


\chapter{Simulazione di BRS}
Si immagini di avere un sistema che si vuole rappresentare usando il formalismo dei bigrafi. Si immagini di aver definito (su carta) un'adeguata segnatura, un bigrafo rappresentante lo stato iniziale, e un insieme adeguato di regole di reazione. Si vuole ora costruire un programma che permetta di \emph{simulare} l'evoluzione del sistema definito sopra.
Innanzitutto bisogna implementare la segnatura, i bigrafi e le regole: per questo ci si appoggia alla libreria JLibBig.
Poi si pone il problema di come far evolvere il sistema, dato che le regole di reazione vengono applicate in modo non-deterministico: non esiste un solo percorso lineare di evoluzione, bensì ve ne sono molteplici, alcuni dei quali magari non hanno senso concretamente; possono addirittura formarsi cicli nell'evoluzione degli stati, portando un eventuale processo di simulazione a non terminare. In buona sostanza, può risultare necessario tenere traccia di tutte le applicazioni delle regole di reazione e di tutti gli stati generati, in modo da poter decidere in seguito quali ci interessano e quali no. 

\`E evidente che un un simulatore è un costrutto complesso: al fine di semplificarne la comprensione, nonché l'implementazione, si propone di suddividerlo in moduli, che verranno discussi uno ad uno. Saranno altre-sì discusse le basi implementative necessarie.

\section{La libreria JLibBig}
JLibBig è una libreria in Java per modellare i bigrafi, reperibile \href{}{dal sito del MADS} dell'Università di Udine. Essa fornisce la base solida su cui si appoggia la parte implementativa di questo lavoro di tesi. Un breve elenco delle \emph{feature} più utili:
\begin{itemize}
\item Permette di modellare segnature e controlli;
\item Permette di modellare bigrafi ed entità associate (p.e. nodi, punti, \emph{handle,...});
\item Permette di agganciare delle proprietà (ovvero coppie $(chiave,valore)$ ) ai nodi dei bigrafi;
\item Implementa le regole di riscrittura e il relativo matching.
\end{itemize}
\paragraph{Cosa non fornisce} La libreria non dà strumenti per gestire l'evoluzione di un sistema reattivo bigrafico nel suo insieme: in particolare non permette di tenere traccia di tutti gli stati generati e di visualizzare i bigrafi. Ci si propone quindi di costruire delle classi che rendano la simulazione dei BRS un'operazione di alto livello, cioè non rendendo necessario occuparsi dei dettagli che essa comporta.

\section{Rappresentare i Bigrafi}
JLibBig fornisce la classe \texttt{Bigraph}, che permette di definire i bigrafi aggiungendo i vari elementi ad un \texttt{BigraphBuilder}, ovvero una \emph{classe factory}. Nella libreria i bigrafi sono oggetti immutabili, quindi ogni volta che vengono modificati dall'applicazione delle regole di riscrittura, in realtà viene generato un nuovo oggetto.

\paragraph{Proprietà} Come anticipato, la libreria permette anche di assegnare ai nodi dei bigrafi delle proprietà, cioè coppie nome-valore; per esempio, si può assegnare dei nomi ai nodi. Questo permette anche di rappresentare informazioni che altrimenti andrebbero codificate nei bigrafi stessi con dei controlli appositi. 


\section{Rappresentare le Regole di Riscrittura}
Anche le regole di riscrittura sono già pronte all'uso in JLibBig, grazie alla classe \texttt{RewritingRule}: si definiscono \emph{redex} e \emph{reactum}, la mappa d'istanziazione e, successivamente, si può applicare la regola chiamando \texttt{apply(Bigraph)}.
\paragraph{Matcher} Per trovare le occorrenze del \emph{redex} nel bigrafo agente si fa affidamento alla classe \texttt{Matcher}, che modella il problema in un \emph{embedding} (un problema di flusso), e lo risolve con tecniche di programmazione a vincoli (appoggiandosi alla libreria \emph{CHOCO Solver}). % Aggiungere qualcosa su embedding? - link a CHOCO

% paragrafo su RewRuleWProps

\section{Modellare il BRS}
Per modellare il BRS viene fornita l'omonima classe, che ha un semplice compito: essa incapsula le regole di riscrittura del sistema e la ``strategia" con cui esse vengono applicate (per esempio, in che ordine); passando un bigrafo al BRS, si ottiene la lista degli stati ottenuti applicandovi le regole.

%Si tenga conto che ogni regola può essere applicata più volte, in quanto il \emph{redex} può avere più di un match: questo significa che, anche con poche regole di riscrittura, lo stato del sistema può ramificarsi significativamente.
\paragraph{Implementazione} Nello specifico, BRS produce una lista di bigrafi o, in alternativa, di coppie $(bigrafo,regolaRiscrittura)$ dette \emph{RuleApplications}, in modo che gli altri moduli del simulatore possano capire che regola ha prodotto una data evoluzione del sistema. Ciò si ottiene chiamando, rispettivamente, i metodi \texttt{apply(Bigraph)} o \texttt{apply\_RA(Bigraph)} (dove \emph{``RA"} sta per \emph{RuleApplication}).
\paragraph{Strategie} Il modulo BRS è stato implementato in modo da poter definire con che criterio vengono applicate le regole di reazione: per esempio, è possibile definire delle regole di riscrittura con priorità, in modo da controllare l'ordine di applicazione. L'implementazione standard usa una strategia stile \emph{``breadth first"}, cioè applica le regole nell'ordine in cui sono date, esplorando gli stati successivi del sistema ``in larghezza".


\section{Grafo degli stati}
Com'è noto, dato uno stato del sistema (un bigrafo), in generale è possibile applicarvi più di una regola di riscrittura (non-deterministicamente); inoltre, una regola può essere applicata in più punti di ogni bigrafo, generando evoluzioni diverse del sistema.
Per questo motivo si propone di costruire un \emph{grafo degli stati}, che è un grafo orientato in cui:
\begin{itemize}
\item i nodi rappresentano stati del sistema, cioè bigrafi;
\item gli archi indicano le transizioni da uno stato al successivo, e la regola che l'ha prodotta.
\end{itemize}
Questa struttura dati permette di analizzare tutta la storia dell'evoluzione del sistema, e persino di generare tutti gli stati possibili (cosa che può essere sfruttata nel model checking).

\paragraph{Problematiche} Dato che si vuole tenere traccia di tutti gli stati generati, si pone la problematica di come gestire i cicli nel grafo: ovvero come riconoscere, e gestire, la situazione in cui l'applicazione di una regola di riscrittura genera uno stato già presente nel grafo? Nell'implementazione standard è stato deciso di \emph{non} introdurre cicli nel grafo, per facilitarne la visita; pertanto, ogni volta che si vuole aggiungere uno stato al grafo, si controlla se ne esiste già uno \emph{isomorfo}: in tal caso, il nuovo stato non viene aggiunto. Va da sé che così si perdono delle informazioni, che tuttavia sono risultate trascurabili nel presente lavoro di tesi, e si è ottenuta una notevole semplificazione in altri moduli che visitano il grafo.

\paragraph{Implementazione} Il grafo degli stati è implementato dalla classe \texttt{BigStateGraph}, i nodi da \texttt{BSGNode} e gli archi da \texttt{BSGLink} (dove \emph{``BSG"} sta per \emph{BigStateGraph}). Il grafo viene inizializzato con un singolo nodo, che rappresenta lo stato iniziale del sistema. I nodi sono mantenuti in una tabella di hash; la funzione di hash viene fornita dall'interfaccia \texttt{BigHashFunction}, la cui implementazione standard (\texttt{PlaceLinkHash}) genera un numero intero in base alla struttura del \emph{place graph} e \emph{link graph} del bigrafo.
Per aggiungere un nodo si usa il metodo \texttt{applyRewritingRule(BSGNode node, String name, Bigraph state)}, che aggiunge un nuovo nodo figlio di \texttt{node}, con stato \texttt{state}, prodotto applicando la regola di nome \texttt{name} a \texttt{node}.
Per verificare se ci sono nodi duplicati si svolge una ricerca in due fasi:
\begin{itemize}
\item Si verifica se c'è una collisione nella tabella di hash tra il nodo che si vuole aggiungere ed uno esistente;
\item Se è così, si controlla se i due stati sono isomorfi sfruttando la classe \texttt{Isomorphism}, ed in particolare il suo metodo \texttt{areIsomorph(Bigraph,Bigraph)}.
\end{itemize}
\paragraph{Nota}L'implementazione della classe \texttt{Isomorphism} non è oggetto di questa tesi; ci si limita a specificare che essa modella il problema dell'isomorfismo tra bigrafi come un'eguaglianza di flusso, risolto con tecniche di programmazione a vincoli. Per ulteriori dettagli si rimanda il lettore a \cite{Geatti:tesiBRS}.


\section{Comporre il Simulatore}
A questo punto si dispone di tutti i moduli necessari a costruire un simulatore di sistemi bigrafici:
\begin{itemize}
\item \texttt{BRS} permette di gestire l'applicazione delle regole come si ritiene opportuno;
\item \texttt{BigStateGraph} permette tenere traccia dell'evoluzione del sistema e di ``ramificare" la simulazione in più percorsi;
\end{itemize}
Si definisce pertanto il modulo \texttt{Sim}, che sfrutta entrambi in maniera trasparente, fornendo un'interfaccia di più alto livello per simulare sistemi bigrafici. \`E implementato come una \emph{classe astratta} (non istanziabile), che fornisce la API di base, e che va estesa in base alle necessità dell'utente. In particolare tale API prevede la possibilità di fare un ``passo" avanti nella simulazione (cioè applicare le regole ad uno o più stati raggiunti in base alle logiche definite dal programmatore), e di sapere se sono stati esplorati tutti gli stati possibili del sistema.
Di seguito vengono descritte alcune implementazioni già definite di \texttt{Sim}.
\subsection{BreadthFirstSim}
\texttt{BreadthFirstSim} è un simulatore che segue una logica \emph{``breadth-first"}, ovvero ad ogni passo applica tutte le regole del BRS (anch'esso con strategia \emph{breadth-first}) a tutti i nodi ``foglia" del grafo. Per far ciò mantiene una coda, in cui inizialmente è presente solo lo stato iniziale; una volta applicate le regole a tale stato, mette gli stati generati in fondo alla coda; ciò viene ripetuto per ogni nodo nella coda, finché essa rimane vuota: a questo punto tutti gli stati possibili sono stati generati.
%\subsection{RandomSim}
\subsection{TrueRandomSim} 
\texttt{TrueRandomSim} è un simulatore che segue un singolo ``ramo" di evoluzione del sistema: per far ciò, ogni volta che vengono generati degli stati applicando le regole di riscrittura, ne viene scelto uno \emph{pseudo}-casualmente e gli altri vengono scartati; in tal modo, il grafo degli stati si riduce ad una catena lineare di nodi con un solo figlio (eccetto l'ultimo nodo). Non è possibile sapere quando si sono esplorati tutti gli stati possibili.

\chapter{Visualizzare i Bigrafi}
Ora che si dispone di un simulatore, sarebbe interessante poter visualizzare i risultati ottenuti nel modo migliore possibile. Tuttavia generare in modo automatico una rappresentazione grafica di bigrafi è un problema complicato, che non è stato ancora risolto. Pertanto, come punto di partenza, si vuole ottenere una rappresentazione testuale; in seguito, si indicherà come produrre una rappresentazione grafica molto semplificata.

\section{Rappresentazione testuale}
JLibBig fornisce già un metodo per tradurre un bigrafo in testo, ovvero \texttt{Bigraph.toString()}; tuttavia il formato è poco leggibile, perciò si propone di migliorare questo risultato andando a definire una classe \emph{pretty-printer}: tale classe legge l'oggetto \texttt{Bigraph}, costruendone una sua rappresentazione interna (ad albero), e lo stampa visualizzando le proprietà dei nodi (in particolare le propietà con nome del tipo \emph{``*Name"}).

\lstinputlisting[breaklines,frame=single,caption=Un estratto di \emph{pretty-print} di un bigrafo,firstline=14, lastline=38]{lst/prettyprint.txt}

\lstinputlisting[breaklines,frame=single,caption=Un estratto di \texttt{Bigraph.toString} sullo stesso bigrafo,firstline=14, lastline=38]{lst/bigraphToString.txt}

In particolare si noti che il \emph{pretty-printer}:
\begin{itemize}
\item indenta il testo per visualizzare la gerarchia dei nodi;
\item identifica le entità del bigrafo come nodi, radici, nomi esterni...
\item permette di visualizzare sia il nome del nodo (se fornito dall'utente) che l'ID usato da JLibBig;
\item identifica e numera esplicitamente le porte dei nodi, ove presenti.
\end{itemize}

\section{Rappresentazione grafica}
Come anticipato, non esiste un algoritmo preciso ed affidabile per generare automaticamente la rappresentazione grafica dei bigrafi; al contrario, il campo della visualizzazione dei grafi è stato soggetto ad estesa ricerca, e sono disponibili linguaggi e programmi già pronti. Pertanto si è deciso di fornire una rappresentazione semplificata dei bigrafi in questo modo:
\begin{itemize}
\item[1.] un parser trasforma il bigrafo in un grafo orientato, rappresentato in \emph{DOT Language};
\item[2.] si usa \emph{GraphViz} per trasformare il file \emph{dot} in un'immagine vettoriale \emph{svg};
\item[3.] a questo punto si può visualizzare l'immagine con un \emph{browser}, o un visualizzatore che ne supporta il formato.
\end{itemize}
\paragraph{Gli strumenti} Il \emph{parser} citato al punto 1 è implementato dalla classe \texttt{DotLangPrinter}, che internamente funziona similarmente al \emph{pretty-printer}. Il \emph{DOT Language} è un formalismo nato per rappresentare grafi orientati e non orientati, permettendo di specificare proprietà per i nodi come colore, forma etichetta, etc\dots.
\emph{GraphViz} è un programma \emph{open-source} che genera immagini di grafi, data la loro descrizione in DOT. Di seguito è riportato un esempio:
% cambiare esempio!!!
\lstinputlisting[breaklines,frame=single,caption=Esempio di bigrafo in DOT %(Estratto)
]{lst/mult.dot}


\begin{figure}[ht]
\includegraphics[height=0.3 \textheight]{mult}
\caption{\emph{Render} di GraphViz del bigrafo}
\end{figure} 

\section{Model Checking}
\subsection{Predicati}

\chapter{Esempi e applicazioni}
\section{Viaggio in macchina}

% altro...
\chapter{Conclusioni}

% Bibliografia
\cleardoublepage
%\phantomsection
\addcontentsline{toc}{chapter}{\bibname}
\printbibliography

\end{document}