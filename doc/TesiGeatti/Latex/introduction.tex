\introduction\label{ch:intro}
Il lavoro riportato in questa tesi nasce dal problema di verificare delle proprietà in un Sistema Reattivo Bigrafico (BRS). In particolare, si è studiato il modo di controllare il sistema durante la sua evoluzione e dunque di fermare quest'ultima appena le proprietà desiderate siano state raggiunte. Questo tipo di verifica va sotto il nome di ``Model Checking''.\\

I Sistemi Reattivi Bigrafici (BRS) sono un nuovo formalismo con il quale si possono rappresentare sistemi distribuiti, di qualsiasi tipo essi siano: da un sistema di smartphones
ad un sistema biologico \cite{Damgaard08ageneric}. I BRS sono basati su un' importante struttura matematica: i bigrafi. Sono questi che permettono una facile trattazione dei vari ``oggetti distribuiti" che compongono il sistema, e di come essi interagiscono tra di loro.\\

L' importanza dei bigrafi la si può riscontrare nella loro flessibilità: essi costituiscono un \emph{meta-modello}, con cui è possibile rappresentare sistemi di qualsiasi dominio si voglia. Di recente i bigrafi sono stati usati per creare delle Reti di Petri \cite{DBLP:conf/ac/Milner03}, come anche per controllare un sistema mobile di robot \cite{pereiranetworked}.

Un altro punto di forza dei bigrafi sta nella loro capacità di evolversi, potendo così rappresentare lo stato del sistema anche quando questo cambia. Si ha così a 
disposizione un Sistema Reattivo Bigrafico. \\

Questa tesi tratta il problema di come poter sapere se un dato BRS rispetti certe proprietà. Per esempio: se rappresentiamo una rete con un BRS, ci possiamo chiedere se, 
dato uno stato iniziale in cui il pacchetto parte dal mittente A, esso arrivi o meno al destinatario B che si trova a vari router di distanza da A.
Oppure, cambiando dominio del problema, ci possiamo domandare se, data una configurazione iniziale del gioco della vita, il giocatore X possa vincere ed entro quante
mosse.

Nei precedenti due casi, le proprietà da verificare sono rispettivamente l'arrivo a destinazione del pacchetto e la condizione di vincita al gioco della vita.\\


Il problema affrontato in questa sede prescinde quindi dal particolare dominio del problema, ed offre una soluzione generale, cioè valida per qualsiasi BRS.
Per fare questo, si sono dovute affrontare varie problematiche. Tra le più importanti figurano:
\begin{itemize}
  \item
  quando due bigrafi sono uguali? Un BRS evolve senza memoria degli stati precedenti in cui si è trovato. Questo problema, in concreto, può potenzialmente
  causare evoluzioni infinite del BRS: per esempio, il pacchetto nella rete può girare all'infinito tra due router, perchè il BRS si "dimentica" da dove il pacchetto
  è arrivato.
  \item
  come rappresentare le proprietà da verificare nel BRS? In particolare, posso rappresentare con un solo formalismo vari tipi di proprietà, dall'arrivo a destinazione di
  un pacchetto alla condizione di vincita di un gioco?
  Il problema maggiore è il fatto che il modo per rappresentarle deve essere generale tanto quanto i BRS. In
  sostanza si è scelto un modo che astraesse ancora una volta dal dominio scelto. \\ \\
\end{itemize}



La struttura della tesi rispetta dunque queste problematiche:\\

Nel capitolo \ref{ch:bigraphs} verranno presentate formalmente le nozioni di Bigrafo e di BRS. Con esse, verrà anche descritta un'algebra per creare nuovi bigrafi a partire da
bigrafi base.\\

Nel capitolo 2 si affronta il primo dei due principali problemi, che va sotto il nome di "isomorfismo tra bigrafi". La risoluzione di questo problema ci permetterà di poter affermare
quando due bigrafi sono uguali o meno, e quindi di evitare evoluzioni infinite del BRS.\\

Si affronterà nel capitolo 3 il secondo problema, cioè quello delle proprietà. Esse verranno espresse sul calcolatore tramite una semplice logica a predicati. Si potranno così
esprimere tutte le proprietà desiderate, indipendentemente dal dominio del sistema. Grazie a queste proprietà, si arriverà all'implementazione di un Model Checker per i bigrafi.
\\

Nel capitolo 4 verranno presentati alcuni esempi, presi da vari domini. Si potrà apprezzare l'importanza di avere un Model Checker e della semplicità con cui si possono
esprimere le proprietà da verificare.\\

Infine (capitolo 5), si sono tratte le conclusioni sull'intero lavoro. Verranno presentate alternative per l'implementazione dell'isomorfismo e delle proprietà.


















