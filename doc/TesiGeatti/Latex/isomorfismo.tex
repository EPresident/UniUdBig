\chapter{Isomorfismo tra bigrafi}
Si è visto nel precedente capitolo come un bigrafo sia capace di evolversi all'interno di un BRS. In alcune situazioni, si vuole evitare evoluzioni infinite di un bigrafo, perchè
per esempio porterebbero sempre a stati uguali fra di loro.\\
Per tenere traccia all'istante $t_k$ di tutti gli stati precedentemente assunti da un BRS ($t_0 \dots t_{k-1}$), si è costruita una struttura dati a grafo, dove ogni nodo
è uno stato, cioè un bigrafo: si chiamerà questo grafo  ``\emph{grafo degli stati}". Se un BRS parte dallo stato $S_0$, è possibile che dopo $K$ regole di reazione lo stato $S_k$ sia uguale allo stato iniziale $S_0$. 
Questo significa che $S_0$ e $S_k$ hanno la stessa \emph{semantica}, cioè rappresentano lo stesso stato del sistema. Per cui, nel grafo degli stati, essi dovranno essere
lo stesso medesimo nodo. \\
Questo è equivalente a scrivere: ``se lo stato $S_{k}$ è stato ottenuto da $S_{k-1}$ tramite la regola $R$ e $S_k$ e $S_0$ sono isomorfi, allora da $S_{k-1}$ si ottiene
$S_0$"
\begin{center}
se $S_{k-1}\stackrel{R}{\longrightarrow}S_{k}$ e $ S_k \bumpeq S_0 \qquad$ allora $S_{k-1}\stackrel{R}{\longrightarrow}S_{0}$
\end{center}
Capire quando due bigrafi sono isomorfi e quindi \emph{semanticamente equivalenti} è di fondamentale importanza se si vogliono evitare i così detti \emph{loop} fra regole: per evitare che fra $S_{i}$ e $S_{i+1}$ si continuino ad applicare sempre le due stesse regole $R_1$ e $R_2$ all'infinito, devo capire che:
\begin{itemize} 
	\item
	da $S_{i}$, tramite la regola $R_1$, ottengo un bigrafo isomorfo a $S_{i+1}$
	\item
	da $S_{i+1}$, tramite la regola $R_2$, ottengo un bigrafo isomorfo a $S_{i}$
\end{itemize}
Questo concetto verrà chiarito con gli esempi sottostanti.

\subsection{Esempio:}\label{sub:networkExe}
Si prenda l'esempio di una rete modellata tramite un bigrafo: si vuole fare in modo che, dato un pacchetto iniziale che ha
come mittente l'host A, esso arrivi al destinatario B. Ci saranno quindi delle regole di reazione per i router, che permetteranno di inoltrare i pacchetti verso le sue interfacce
di uscita. Poichè, utilizzando i soli bigrafi, servirebbero troppe regole di reazione per modellare il fatto che se il destinario è X allora l'interfaccia di uscita del pacchetto è la numero N,  si può pensare di inoltrare il pacchetto verso tutte le uscite in modo non deterministico. Così facendo, il pacchetto arriverà sicuramente al destinatario.
I problemi sono ora due:
\begin{itemize}
	\item
	il pacchetto arriverà a destinatari non corretti. Si può introdurre una regola di reazione che elimini dall'host ogni pacchetto che non ha l'host stesso come destinatario.
	\item
	se prendiamo il $k-esimo$ router $R_k$, allora il pacchetto ritornerà al $k-1 esimo$ router $R_{k-1}$ , che a sua volta lo inoltrerà verso tutte le sue interfacce, e quindi 
	anche nuovamente verso $R_{k}$. Si ha così un ciclo infinito di pacchetti tra $R_k$ e $R_{k-1}$.
\end{itemize}

In questa sede si tratterà il secondo di questi problemi, che ha un'apparentemente semplice soluzione: capire quando due bigrafi sono uguali. In questo esempio, è 
facile capire che per risolvere il problema basta verificare se gli stati $S_{k+i}$ e $S_{k-1}$ sono uguali: se $S_{k}$ è il bigrafo in cui il pacchetto è nel router $R_{k}$, allora
si applica la regola di inoltro e si generano tanti stati ($S_{k+1} \dots S_{k+j}$) quanti sono i router vicini a $R_k$; tra di questi ci sara anche $R_{k-1}$. Quindi, se supponiamo
che nello stato $S_{k+i}$ il pacchetto torni indietro al router $R_{k-1}$, allora il problema è capire che $S_{k+i}$ è uguale $S_{k-1}$, cioè verificare che i due bigrafi siano
isomorfi. In questo modo si sa che dallo stato $S_{k-1}$ non si dovrà più applicare la regola di inoltro verso $S_{k}$, perchè questo causerebbe un ciclo infinito.

\section{Formulazione del problema}
Si è visto che il termine isomorfismo ci aiuta a capire quando due bigrafi sono uguali. Riportiamo di nuovo la sua definizione formale (\ref{def:iso}):
\begin{define}[Isomorfismo]
Due bigrafi F e G si dicono isomorfi se e solo se esiste una traduzione di supporto tra F e G, cioè se e solo se F e G sono \emph{support equivalent} ($F \bumpeq G$).
\end{define}

Il problema consiste quindi nel trovare un funzione biettiva che ha come dominio i nodi e gli archi del primo bigrafo, come codominio quelli del secondo bigrafo e che ne rispetti
la struttura del primo. Come già visto, tale funzione si chiama \emph{traduzione di supporto}.\\
Si noti come la traduzione di supporto consenta di ritenere isomorfi due bigrafi che sono uguali \emph{modulo permutazione}: tale funzione può infatti operare una permutazione sui nomi dei nodi e degli archi, così come sugli inner names e outer names. In altre parole, non c'è nessun vincolo sui nomi, ma solo sulla struttura del bigrafo. Si capirà meglio questo concetto negli esempi che seguiranno.

\section{Strategia di soluzione}
Dal punto di vista teorico, si è trattato questo problema come una \emph{rete di flusso}: esse consentono di specificare in modo molto preciso delle condizioni sulla \emph{struttura} dei grafi. Qui l'obbiettivo è trovare una traduzione di supporto, che conservi la struttura e sia biettiva: quest'ultima caratteristica può essere espressa come
il fatto che ogni nodo del primo bigrafo deve essere associato ad uno ed un solo nodo del secondo bigrafo. Tramite la rete di flusso, si può specificare questa condizione 
dicendo che il flusso in uscita da ogni nodo deve essere esattamente 1. Questo è un primo esempio del motivo per cui si è scelta una rete di flusso per modellare il problema.

Si è scelto di trattare questo problema tramite la programmazione a vincoli. Questo paradigma permette di rappresentare al calcolatore un sistema di equazioni, che esso
risolverà. Le equazioni saranno i vincoli che la rete di flusso dovrà rispettare. Nel nostro caso, ci basterà capire se esiste una soluzione al sistema, e non ci interessa sapere quali sono le sue soluzioni. Tutte le equazioni scritte sono lineari,
con la conseguenza che si avrà un sistema lineare: questo permette di abbassare la complessità dell'algoritmo.\\
Si è usata la libreria Java \emph{Choco vs 3.3.1} per esprimere tutti i vincoli.\\

Si è precedentemente visto che ogni bigrafo è formato da due strutture ortogonali e totalmente indipendenti, il place graph ed il link graph. Il problema dell'isomorfismo verrà quindi trattato
separatamente per le due strutture: ci saranno dei vincoli solamente per il place graph, ed altri solamente per il link graph. Infine, gli ultimi vincoli serviranno per conciliare le due soluzioni: si vedrà che senza di questi il calcolatore riconoscerà come uguali due bigrafi che hanno lo stesso link graph e lo stesso place graph modulo permutazione ma che non sono isomorfi (figura \ref{fig:falseIso}).\\

La definizione di isomorfismo vista precedentemente può far credere che esso sia un termine puramente sintattico, cioè che riguardi solamente la struttura dei due bigrafi. L'isomorfismo è invece un'operazione che riguarda anche la semantica: due bigrafi strutturalmente uguali sono due bigrafi che hanno la stessa semantica (figura \ref{fig:bigMulIso}).

\subsection{Esempi}\label{sub:isoExamples}
Non è sempre banale capire quando due bigrafi sono isomorfi. Si forniscono quindi alcuni esempi per acquisire familiarità con questo concetto. 

Il primo riprende il bigrafo di figura \ref{fig:bigMul} per la moltiplicazione tra numeri naturali. Si vuole mostrare che, semanticamente, l'operazione $2*4$ è equivalente
all'operazione $4*2$. In altre parole, non importa l'ordine dei nodi.

Incominciamo notando che i due link graph sono isomorfi, perchè non hanno archi e presentano lo stesso numero di nodi. Prendiamo ora in esame il place graph: se si ritorna alla sua definizione, si nota subito i due place graph siano uguali perchè i nodi interni non sono ordinati.

Il fatto di dimostrare che i due bigrafi sono isomorfi e semanticamente equivalenti, dimostra che la proprietà commutativa della moltiplicazione vale anche nella sua versione bigrafica.\\

\begin{figure}[!h]
\centering
\begin{tikzpicture}
%\draw[help lines] (0,0) grid (14,5);
%Root
\draw[rounded corners=4mm,dotted, thick] (1.0,0.0) rectangle (7.0,5.0);
\node[below right] at (1.0,5.0) {0};
%Nodes
\draw[rounded corners=4mm, thick] (1.5,0.5) rectangle (6.5,4.5);%mul
\node[below right] at (1.5,4.5) {mul};
\draw[thick] (2.7,3.0) circle [radius=1.0] ;%num1
\node[below] at (2.6,3.9) {num};
\draw[thick] (2.0,3.0) rectangle (2.4,3.4);%one
\node[above right] at (2.0,2.95) {1};
\draw[thick] (2.8,3.0) rectangle (3.2,3.4);%one
\node[above right] at (2.8,2.95) {1};
\draw[thick] (2.0,2.4) rectangle (2.4,2.8);%one
\node[above right] at (2.0,2.35) {1};
\draw[thick] (2.8,2.4) rectangle (3.2,2.8);%one
\node[above right] at (2.8,2.35) {1};
\draw[thick] (5.3,3.0) circle [radius=1.0] ;%num2
\node[below] at (5.2,3.9) {num};
\draw[thick] (4.6,3.0) rectangle (5.0,3.4);%one
\node[above right] at (4.6,2.95) {1};
\draw[thick] (5.4,3.0) rectangle (5.8,3.4);%one
\node[above right] at (5.4,2.95) {1};

%Root
\draw[rounded corners=4mm,dotted, thick] (8.0,0.0) rectangle (14.0,5.0);
\node[below right] at (8.0,5.0) {0};
%Nodes
\draw[rounded corners=4mm, thick] (8.5,0.5) rectangle (13.5,4.5);%mul
\node[below right] at (8.5,4.5) {mul};
\draw[thick] (9.7,3.0) circle [radius=1.0] ;%num1
\node[below] at (9.6,3.9) {num};
\draw[thick] (9.0,3.0) rectangle (9.4,3.4);%one
\node[above right] at (9.0,2.95) {1};
\draw[thick] (9.8,3.0) rectangle (10.2,3.4);%one
\node[above right] at (9.8,2.95) {1};
\draw[thick] (12.3,3.0) circle [radius=1.0] ;%num2
\node[below] at (12.2,3.9) {num};
\draw[thick] (11.6,3.0) rectangle (12.0,3.4);%one
\node[above right] at (11.6,2.95) {1};
\draw[thick] (12.4,3.0) rectangle (12.8,3.4);%one
\node[above right] at (12.4,2.95) {1};
\draw[thick] (11.6,2.4) rectangle (12.0,2.8);%one
\node[above right] at (11.6,2.35) {1};
\draw[thick] (12.4,2.4) rectangle (12.8,2.8);%one
\node[above right] at (12.4,2.35) {1};

\end{tikzpicture}
\caption{Bigrafi Isomorfi: $(4*2) = (2*4)$ \label{fig:bigMulIso}}
\end{figure}


Presentiamo un altro esempio, questa volta su un caso negativo. Si è specificato che per risolvere il problema si trattano separatamente i casi del place graph e del link graph: questo approccio però necessita di avere dei vincoli di ``coerenza" che uniscano le due soluzioni. Senza questi vincoli, si può incorrere nel seguente problema.

Si considerino i due bigrafi di figura \ref{fig:falseIso} e i loro relativi place graph e link graph (figura \ref{fig:falsoIsoDecap}). Si nota subito che i due bigrafi \emph{non} sono isomorfi. Prendendo però i due place graph ci si accerta che essi lo sono. Lo stesso vale per i due link graph: sono entrambi formati da tre nodi, in cui c'è solamente un edge che collega il cerchio ad un quadrato.

I casi separati del link graph e del place graph sembrano quindi suggerire che i due bigrafi siano isomorfi, mentre si vede subito che non è così. Quello che non abbiamo considerato sono appunto i \emph{vincoli di coerenza}, che informalmente dicono che il quadrato collegato al cerchio (nel primo link graph) deve essere quello che contiene un altro quadrato (nel primo place graph). Aggiunta questa condizione, si nota che le due soluzioni sono \emph{incompatibili}, avendo quindi che i due bigrafi \emph{non} sono isomorfi.




\begin{figure}[!h]
\centering
\begin{tikzpicture}
%\draw[help lines] (0,0) grid (14,5);
%%%   First Bigraph   %%%
%Root
\draw[rounded corners=4mm,dotted, thick] (0.0,0.0) rectangle (6.0,4.0);
\node[below right] at (0.0,4.0) {0};
%Nodes
\draw[rounded corners=3mm, thick] (0.5,0.5) rectangle (3.0,3.0);
\node[above right] at (0.5,3.0) {$Q_1$};
\draw[thick] (4.5,1.5) circle [radius=1.0];
\node[above] at (4.5,2.5) {$C_1$};
\draw[rounded corners=2mm, thick] (1.0,1.0) rectangle (2.0,2.0);
\node[above right] at (1.0,2.0) {$Q_2$};
%Edges
\draw[myGreen, thick] (2.0,3.0) to [out=90,in=90] (4.0,2.35);
\draw[fill=black] (2.0,3.0) circle [radius=0.05];
\draw[fill=black] (4.0,2.35) circle [radius=0.05];


%%%   First Bigraph   %%%
%Root
\draw[rounded corners=4mm,dotted, thick] (7.0,0.0) rectangle (13.0,4.0);
\node[below right] at (7.0,4.0) {0};
%Nodes
\draw[rounded corners=3mm, thick] (7.5,0.5) rectangle (10.0,3.0);
\node[above right] at (7.5,3.0) {$Q_1$};
\draw[thick] (11.5,1.5) circle [radius=1.0];
\node[above] at (11.5,2.5) {$C_1$};
\draw[rounded corners=2mm, thick] (8.0,1.0) rectangle (9.0,2.0);
\node[above right] at (8.0,2.0) {$Q_2$};
%Edges
\draw[myGreen, thick] (8.7,2.0) to [out=90,in=90] (11.0,2.35);
\draw[fill=black] (8.7,2.0) circle [radius=0.05];
\draw[fill=black] (11.0,2.35) circle [radius=0.05];


\end{tikzpicture}
\caption{Bigrafi non Isomorfi\label{fig:falseIso}}
\end{figure}




\begin{figure}[!h]
\centering
\subfigure[Place Graph isomorfi]{
\begin{tikzpicture}
%\draw[help lines] (0,0) grid (14,5);
%%%   First Place Graph   %%%
%Root
\node at (2.5,4.5){0};
%Nodes
\node at (1.5,3.5){$Q_1$};
\node at (3.5,3.5){$C_1$};
\node at (1.5,1.5){$Q_2$};
%Edges
\draw (2.5,4.2) -- (1.5,3.7);
\draw (2.5,4.2) -- (3.5,3.7);
\draw (1.5,3.2) -- (1.5,1.7);

%%%   Second Place Graph   %%%
%Root
\node at (11.5,4.5){0};
%Nodes
\node at (10.5,3.5){$Q_1$};
\node at (12.5,3.5){$C_1$};
\node at (10.5,1.5){$Q_2$};
%Edges
\draw (11.5,4.2) -- (10.5,3.7);
\draw (11.5,4.2) -- (12.5,3.7);
\draw (10.5,3.2) -- (10.5,1.7);

\end{tikzpicture}
}
\hspace{5mm}
\subfigure[Link Graph isomorfi]{
\begin{tikzpicture}
%\draw[help lines] (0,0) grid (14,5);
%%%   First Link Graph   %%%
\draw[thick] (1.0,2.0) circle [radius=0.2];
\node[above left] at (1.0,2.0) {$Q_1$};
\draw[thick] (2.0,4.0) circle [radius=0.2];
\node[above left] at (2.0,4.0) {$C_1$};
\draw[thick] (4.0,2.0) circle [radius=0.2];
\node[above right] at (4.0,2.0) {$Q_2$};
\draw[myGreen,thick] (1.0,2.2) to [out=90,in=270] (2.0,3.8);

%%%   Second Link Graph   %%%
\draw[thick] (10.0,2.0) circle [radius=0.2];
\node[above left] at (10.0,2.0) {$Q_2$};
\draw[thick] (11.0,4.0) circle [radius=0.2];
\node[above left] at (11.0,4.0) {$C_1$};
\draw[thick] (13.0,2.0) circle [radius=0.2];
\node[above right] at (13.0,2.0) {$Q_1$};
\draw[myGreen,thick] (10.0,2.2) to [out=90,in=270] (11.0,3.8);

\end{tikzpicture}
}
\caption{Place Graph e Link Graph del bigrafo \ref{fig:falseIso}\label{fig:falsoIsoDecap}}
\end{figure}






%%%%%%%%%			VINCOLI 				%%%%%%%%%%%
\section{Vincoli}
In questa sezione si presentano le equazioni necessarie per risolvere il problema dell'isomorfismo. Come già anticipato, si lavorerà sulle \emph{reti di flusso}, che sono grafi orientati pesati. Distinguiamo le equazioni per il place graph, per il link graph e per la così detta coerenza.

\subsection{Vincoli per il place graph}
L'isomorfismo tra place graphs è un isomorfismo tra foreste. Si vuole infatti vedere quando la prima foresta è isomorfa alla seconda, a meno di permutazioni delle radici e dei siti. Una rete di flusso per questo problema è quella in figura \ref{fig:placeFlow}.

\begin{figure*}[th]
\centering
\begin{tikzpicture}
	%root
	\draw [fill] (1.0,2.0) circle [radius=0.1];
	%level 1
	\draw [fill] (0.0,1.0) circle [radius=0.1];
	\draw [fill] (2.0,1.0) circle [radius=0.1];
	%level 2
	\draw [fill] (2.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (1.0,1.9) -- (0.0,1.1);
	\draw [myGreen, thick] (1.0,1.9) -- (2.0,1.1);
	\draw [myGreen, thick] (2.0,0.9) -- (2.0,0.1);
	
	
	%root
	\draw [fill] (5.0,2.0) circle [radius=0.1];
	%level 1
	\draw [fill] (4.0,1.0) circle [radius=0.1];
	\draw [fill] (6.0,1.0) circle [radius=0.1];
	%level 2
	\draw [fill] (6.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (5.0,1.9) -- (4.0,1.1);
	\draw [myGreen, thick] (5.0,1.9) -- (6.0,1.1);
	\draw [myGreen, thick] (6.0,0.9) -- (6.0,0.1);
%level 0
\draw [red] (1.1,2.0) to [out=60 , in=180 ] (4.9,2.0);
%level 1
\draw [red] (0.1,1.0) to [out=30 , in=150 ] (3.9,1.0);
\draw [red] (0.1,1.0) to [out=-30 , in=210] (5.9,1.0);
\draw [red] (2.1,1.0) to [out=-30 , in=180 ] (3.9,1.0);
\draw [red] (2.1,1.0) to [out=30 , in=180] (5.9,1.0);
%level 2
\draw [red] (2.1,0.0) to [out=330 , in=180] (5.9,0.0);


\end{tikzpicture}
\caption{Rete di flusso per l'isomorfismo tra place graphs.	\label{fig:placeFlow}}
\end{figure*}



Alle due foreste (cioè ai due place graph, costituiti da archi di colore verde), che chiameremo $P_F$ e $P_G$, si sono aggiunti altri archi (quelli rossi) \emph{solamente} tra nodi della stessa altezza, creando così un grafo. Questa è la vera e propria rete di flusso per il problema dell'isomorfismo tra place graph. Ogni arco rosso è \emph{orientato}, perchè va dai nodi della prima foresta ai nodi della seconda, e \emph{pesato}, perchè gli è assegnato un numero naturale $p \in \{ 0, 1\}$.

Nell'implementazione, trattata tramite la programmazione a vincoli, ogni arco rosso è una variabile. L'insieme delle variabili per il place graph sarà quindi:
\begin{center}
$M_{d,m,n} \in \{ 0, 1\} \qquad 0 \le d \le depth \qquad$\\ $\qquad \qquad m \in P_F^d$ \\ $\qquad \qquad n \in P_G^d$
\end{center}
dove \emph{depth} è l'altezza massima della prima foresta, e $P_F^d$ e $P_G^d$ indicano l'insieme di nodi che si trovano all'altezza $d$ rispettivamente nel place graph $P_F$ e $P_G$.\\
In altre parole, creo una variabile che può assumere valore 0 o 1 per ogni coppia di nodi $(a,b)$ che si trovano sulla stessa altezza, dove $a$ appartiene al primo place graph mentre $b$ al secondo.

I vincoli dovranno essere tali che, dopo l'esecuzione del sistema sul calcolatore, le variabili che assumeranno il valore 1 saranno quelle che \emph{formeranno} la vera e propria traduzione di supporto. Ovvero: 
\begin{prop}\label{prop:traduzioneSupporto}
La variabile $M_{d,m,n}$ assumerà il valore 1 \emph{se e solo se} esiste una traduzione di supporto $\rho$ tale che $\rho(m)=n$.
\end{prop}
Tutte le altre variabili dovranno assumere il valore 0. Un altro modo di vedere la soluzione è questa: la funzione di traduzione di supporto sarà definita da tutte e sole le variabili con valore 1. Infine: 
\begin{term}\label{term:matchVariabili}
Quando la variabile $M_{d,m,n}=1$ diremo che m e n costituiscono un match.
\end{term}

Nell'esempio di figura \ref{fig:placeFlow}, la soluzione esiste ed è definita come in figura \ref{fig:placeFlowRis}, dove i numeri sopra le variabili (archi rossi) indicano i valori che esse hanno assunto dopo la risoluzione del sistema di equazioni.



\begin{figure*}[th]
\centering
\begin{tikzpicture}
%\draw[help lines] (0,0) grid (10,5);
	%root
	\draw [fill] (1.0,2.0) circle [radius=0.1];
	%level 1
	\draw [fill] (0.0,1.0) circle [radius=0.1];
	\draw [fill] (2.0,1.0) circle [radius=0.1];
	%level 2
	\draw [fill] (2.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (1.0,1.9) -- (0.0,1.1);
	\draw [myGreen, thick] (1.0,1.9) -- (2.0,1.1);
	\draw [myGreen, thick] (2.0,0.9) -- (2.0,0.1);
	
	
	%root
	\draw [fill] (5.0,2.0) circle [radius=0.1];
	%level 1
	\draw [fill] (4.0,1.0) circle [radius=0.1];
	\draw [fill] (6.0,1.0) circle [radius=0.1];
	%level 2
	\draw [fill] (6.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (5.0,1.9) -- (4.0,1.1);
	\draw [myGreen, thick] (5.0,1.9) -- (6.0,1.1);
	\draw [myGreen, thick] (6.0,0.9) -- (6.0,0.1);
%level 0
\draw [red] (1.1,2.0) to [out=60 , in=180 ] (4.9,2.0);
\node[above] at (2.0,2.5) {1};
%level 1
\draw [red] (0.1,1.0) to [out=30 , in=150 ] (3.9,1.0);
\node[above] at (2.0,1.5) {1};
\draw [red] (0.1,1.0) to [out=-30 , in=210] (5.9,1.0);
\node[above] at (1.0,0.5) {0};
\draw [red] (2.1,1.0) to [out=-30 , in=180 ] (3.9,1.0);
\node[above] at (3.0,0.5) {0};
\draw [red] (2.1,1.0) to [out=30 , in=180] (5.9,1.0);
\node[above] at (5.5,1.0) {1};
%level 2
\draw [red] (2.1,0.0) to [out=330 , in=180] (5.9,0.0);
\node[above left] at (6.0,0.0) {1};


\end{tikzpicture}
\caption{Soluzione della rete di flusso \label{fig:placeFlowRis}}
\end{figure*}

Riassumendo, dobbiamo tradurre in vincoli il fatto che la funzione di traduzione di supporto sia biiettiva e che conservi la struttura del place graph $P_F$. Distingueremo quindi in vincoli di flusso, che servono per il primo problema, e in vincoli strutturali, per il secondo.

Incominciamo con i \textbf{vincoli strutturali}: si è adottata una versione ricorsiva per i vincoli. Distinguiamo quindi in caso base e passo ricorsivo.
\begin{itemize}
	\item
	\emph{Caso Base}: due nodi della stessa altezza che hanno un numero diverso di figli \emph{non} possono costituire un match. In formule:
	\begin{center}
	$M_{d,m,n} = 0 \qquad$ se $|prnt_F^{-1}(m)| \ne |prnt_G^{-1}(n)|$ \\ $\qquad \forall d\leq depth - 1$ \\ $ \qquad \qquad \forall m \in P_F^d$ e $n \in P_G^d$
	\end{center}
	Nella figura sottostante, si vede subito che la variabile $M_{0,r_0,r_0}=0$ perchè $prnt_F^{-1}(r_0)=1 \ne 2=prnt_G^{-1}(r_0)$.
	
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (10,5);
	%root 1
	\draw [fill] (1.0,2.0) circle [radius=0.1];
	%level 1.1
	\draw [fill] (0.0,1.0) circle [radius=0.1];
	\draw [fill] (2.0,1.0) circle [radius=0.1];
	%level 1.2
	\draw [fill] (2.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (1.0,1.9) -- (0.0,1.1);
	\draw [myGreen, thick] (1.0,1.9) -- (2.0,1.1);
	\draw [myGreen, thick] (2.0,0.9) -- (2.0,0.1);
	
	%root 2
	\draw [fill] (3.0,2.0) circle [radius=0.1];
	\node[above left] at (3.0,2.0){$r_0$};
	%level 2.1
	\draw [fill] (3.0,1.0) circle [radius=0.1];
	%level 2.2
	\draw [fill] (3.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (3.0,1.9) -- (3.0,1.1);
	\draw [myGreen, thick] (3.0,0.9) -- (3.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%
	
	%root 1
	\draw [fill] (8.0,2.0) circle [radius=0.1];
	\node[above right] at (8.0,2.0){$r_0$};
	%level 1.1
	\draw [fill] (7.0,1.0) circle [radius=0.1];
	\draw [fill] (9.0,1.0) circle [radius=0.1];
	%level 1.2
	\draw [fill] (9.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (8.0,1.9) -- (7.0,1.1);
	\draw [myGreen, thick] (8.0,1.9) -- (9.0,1.1);
	\draw [myGreen, thick] (9.0,0.9) -- (9.0,0.1);
	
	%root 2
	\draw [fill] (6.0,2.0) circle [radius=0.1];
	%level 2.1
	\draw [fill] (6.0,1.0) circle [radius=0.1];
	%level 2.2
	\draw [fill] (6.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (6.0,1.9) -- (6.0,1.1);
	\draw [myGreen, thick] (6.0,0.9) -- (6.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%%
	
	\draw[red] (3.0,2.1) to [out=20,in=160] (8.0,2.1);
	\node[above] at (5.0,2.5){0}; 
	
	\end{tikzpicture}
	\caption{Esempio per il primo vincolo \label{fig:firstConstraintExe}}
	\end{figure*}
	Si noti che questo vincolo viene applicato a tutti i nodi tranne ai siti, come specificato dalla condizione $\forall d\leq depth - 1$.
	
	\item
	\emph{Caso Ricorsivo}:  se due nodi alla stessa altezza \emph{non} costituiscono un match, allora neanche i loro figli lo fanno. In formule:
	\begin{center}
	$M_{d,m,n} \le M_{d-1,prnt(m), prnt(n)} \qquad \forall d \ge 1\qquad \qquad$ \\ $\qquad \qquad \qquad \qquad \qquad \qquad \forall m \in P_F^d$ \\ $\qquad \qquad \qquad \qquad \qquad \qquad 	\forall n \in P_G^d$
	\end{center}
	Questo vincolo modella la seguente implicazione: 
	\begin{center}
	$M_{d-1,prnt(m), prnt(n)}=0 \qquad \Rightarrow \qquad M_{d,m,n}=0$
	\end{center}
	Esso costituisce il caso ricorsivo perchè vale per tutti i nodi tranne le radici, e le radici sono ricoperte dal caso base. Si veda la figura \ref{fig:secondConstraintExe}: la variabile 
	$M_{1,n_1,n_2}=0$ perchè dalla figura \ref{fig:firstConstraintExe} sappiamo che $M_{0,r_0,r_0}=0$ e perchè $prnt_F(n_1)=r_0$ e $prnt_G(n_2)=r_0$. Lo stesso ragionamento vale per la variabile $M_{1,n_1,n_3}$. \\ \\ \\ \\ \\ \\
	
	
		
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (10,5);
	%root 1
	\draw [fill] (1.0,2.0) circle [radius=0.1];
	%level 1.1
	\draw [fill] (0.0,1.0) circle [radius=0.1];
	\draw [fill] (2.0,1.0) circle [radius=0.1];
	%level 1.2
	\draw [fill] (2.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (1.0,1.9) -- (0.0,1.1);
	\draw [myGreen, thick] (1.0,1.9) -- (2.0,1.1);
	\draw [myGreen, thick] (2.0,0.9) -- (2.0,0.1);
	
	%root 2
	\draw [fill] (3.0,2.0) circle [radius=0.1];
	\node[above left] at (3.0,2.0){$r_0$};
	%level 2.1
	\draw [fill] (3.0,1.0) circle [radius=0.1];
	\node[above left] at (3.0,1.0) {$n_1$};
	%level 2.2
	\draw [fill] (3.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (3.0,1.9) -- (3.0,1.1);
	\draw [myGreen, thick] (3.0,0.9) -- (3.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%
	
	%root 1
	\draw [fill] (8.0,2.0) circle [radius=0.1];
	\node[above right] at (8.0,2.0){$r_0$};
	%level 1.1
	\draw [fill] (7.0,1.0) circle [radius=0.1];
	\node[above left] at (7.0,1.0){$n_2$};
	\draw [fill] (9.0,1.0) circle [radius=0.1];
	\node[above right] at (9.0,1.0){$n_3$};
	%level 1.2
	\draw [fill] (9.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (8.0,1.9) -- (7.0,1.1);
	\draw [myGreen, thick] (8.0,1.9) -- (9.0,1.1);
	\draw [myGreen, thick] (9.0,0.9) -- (9.0,0.1);
	
	%root 2
	\draw [fill] (6.0,2.0) circle [radius=0.1];
	%level 2.1
	\draw [fill] (6.0,1.0) circle [radius=0.1];
	%level 2.2
	\draw [fill] (6.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (6.0,1.9) -- (6.0,1.1);
	\draw [myGreen, thick] (6.0,0.9) -- (6.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%%
	
	\draw[red] (3.0,2.1) to [out=20,in=160] (8.0,2.1);
	\node[above] at (5.0,2.5){0}; 
	\draw[red] (3.1,1.0) to [out=20,in=170] (6.9,1.0);
	\node[above] at (4.0,1.2){0};
	\draw[red] (3.1,1.0) to [out=-20,in=190] (8.9,1.0);
	\node[above] at (5.0,0.5){0};
	
	\end{tikzpicture}
	\caption{Esempio per il secondo vincolo \label{fig:secondConstraintExe}}
	\end{figure*}
\end{itemize}


Questi vincoli non sono però sufficienti per determinare un isomorfismo tra i due place graph $P_F$ e $P_G$. In particolare, la traduzione di supporto deve essere biiettiva, cioè associare un nodo/radice/sito di $P_F$ ad uno ed un solo nodo/radice/sito di $P_G$. Si sono quindi aggiunti i \textbf{vincoli di flusso}.

\begin{itemize}
	\item
	\emph{Flusso in uscita}: il flusso totale in uscita da ogni nodo deve essere esattamente pari a 1. 
	\begin{notaz}
	Questo vincolo lo indicheremo con la notazione: $\delta^{+}(m)=1$, dove $m \in P_F^d$.
	\end{notaz}
	Esso si traduce nel fatto che la somma di tutte le variabili in uscita da ogni nodo/radice/sito di $P_F$ deve essere 1, ovvero: ogni nodo di F può costituire un match solamente con uno ed un solo altro nodo di G. In formule:
	\begin{center}
	$\sum\limits_{n}M_{d,m,n} = 1 \qquad 0 \le d \le depth \qquad  $ \\ $ \qquad \qquad m \in P_F^d$ \\ $ \qquad \qquad n \in P_G^d$
	\end{center}
	
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (10,5);
	%root 1
	\draw [fill] (1.0,2.0) circle [radius=0.1];
	%level 1.1
	\draw [fill] (0.0,1.0) circle [radius=0.1];
	\draw [fill] (2.0,1.0) circle [radius=0.1];
	%level 1.2
	\draw [fill] (2.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (1.0,1.9) -- (0.0,1.1);
	\draw [myGreen, thick] (1.0,1.9) -- (2.0,1.1);
	\draw [myGreen, thick] (2.0,0.9) -- (2.0,0.1);
	
	%root 2
	\draw [fill] (3.0,2.0) circle [radius=0.1];
	%level 2.1
	\draw [fill] (3.0,1.0) circle [radius=0.1];
	\node[above left] at (3.0,1.0) {$n_1$};
	%level 2.2
	\draw [fill] (3.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (3.0,1.9) -- (3.0,1.1);
	\draw [myGreen, thick] (3.0,0.9) -- (3.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%
	
	%root 1
	\draw [fill] (8.0,2.0) circle [radius=0.1];
	%level 1.1
	\draw [fill] (7.0,1.0) circle [radius=0.1];
	\node[above right] at (7.0,1.0){$n_2$};
	\draw [fill] (9.0,1.0) circle [radius=0.1];
	\node[above right] at (9.0,1.0){$n_3$};
	%level 1.2
	\draw [fill] (9.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (8.0,1.9) -- (7.0,1.1);
	\draw [myGreen, thick] (8.0,1.9) -- (9.0,1.1);
	\draw [myGreen, thick] (9.0,0.9) -- (9.0,0.1);
	
	%root 2
	\draw [fill] (6.0,2.0) circle [radius=0.1];
	%level 2.1
	\draw [fill] (6.0,1.0) circle [radius=0.1];
	\node[above right] at (6.0,1.0){$n_1$};
	%level 2.2
	\draw [fill] (6.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (6.0,1.9) -- (6.0,1.1);
	\draw [myGreen, thick] (6.0,0.9) -- (6.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%%
	
	\draw[red] (3.1,1.0) to [out=50,in=130] (6.9,1.0);%n1-n2
	\node at (4.0,2.0){0};
	\draw[red] (3.1,1.0) to [out=-30,in=210] (8.9,1.0);%n1-n3
	\node[above] at (4.0,0.0){0};
	\draw[red] (3.1,1.0) to [out=20,in=170] (5.9,1.0);%n1-n1
	\node[above] at (5.0,1.2){1};
	
	
	\end{tikzpicture}
	\caption{Esempio per il vincolo sul flusso in uscita \label{fig:thirdConstraintExe}}
	\end{figure*}
	In figura \ref{fig:thirdConstraintExe} si può vedere come la somma degli archi in uscita dal nodo $n_1$ sia 1, ovvero: 
	$M_{1,n_1,n_1}+M_{1,n_1,n_2}+M_{1,n_1,n_3}=1$. \\
	
	\item
	\emph{Flusso in entrata}: il flusso totale in entrata da ogni nodo deve essere esattamente pari a 1.
	\begin{notaz}
	Questo vincolo lo indicheremo con la notazione: $\delta^{-}(n)=1$, dove $n \in P_G^d$.
	\end{notaz}
	Esso è equivalente a dire che la somma di tutte le variabili in entrata da ogni nodo/radice/sito di $P_G$ deve essere 1. In altre parole: ogni nodo di G può costituire un match solamente con uno ed un solo altro nodo di F. In formule:
	\begin{center}
	$\sum\limits_{m}M_{d,m,n} = 1 \qquad 0 \le d \le depth \qquad  $ \\ $ \qquad \qquad m \in P_F^d$ \\ $ \qquad \qquad n \in P_G^d$
	\end{center}
	
	
	
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (10,5);
	%root 1
	\draw [fill] (1.0,2.0) circle [radius=0.1];
	%level 1.1
	\draw [fill] (0.0,1.0) circle [radius=0.1];
	\node[above left] at (0.0,1.0){$n_2$};
	\draw [fill] (2.0,1.0) circle [radius=0.1];
	\node[below left] at (2.0,1.0){$n_3$};
	%level 1.2
	\draw [fill] (2.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (1.0,1.9) -- (0.0,1.1);
	\draw [myGreen, thick] (1.0,1.9) -- (2.0,1.1);
	\draw [myGreen, thick] (2.0,0.9) -- (2.0,0.1);
	
	%root 2
	\draw [fill] (3.0,2.0) circle [radius=0.1];
	%level 2.1
	\draw [fill] (3.0,1.0) circle [radius=0.1];
	\node[above left] at (3.0,1.0) {$n_1$};
	%level 2.2
	\draw [fill] (3.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (3.0,1.9) -- (3.0,1.1);
	\draw [myGreen, thick] (3.0,0.9) -- (3.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%
	
	%root 1
	\draw [fill] (8.0,2.0) circle [radius=0.1];
	%level 1.1
	\draw [fill] (7.0,1.0) circle [radius=0.1];
	\draw [fill] (9.0,1.0) circle [radius=0.1];
	%level 1.2
	\draw [fill] (9.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (8.0,1.9) -- (7.0,1.1);
	\draw [myGreen, thick] (8.0,1.9) -- (9.0,1.1);
	\draw [myGreen, thick] (9.0,0.9) -- (9.0,0.1);
	
	%root 2
	\draw [fill] (6.0,2.0) circle [radius=0.1];
	%level 2.1
	\draw [fill] (6.0,1.0) circle [radius=0.1];
	\node[above right] at (6.0,1.0){$n_1$};
	%level 2.2
	\draw [fill] (6.0,0.0) circle [radius=0.1];
	%tree-edges G
	\draw [myGreen, thick] (6.0,1.9) -- (6.0,1.1);
	\draw [myGreen, thick] (6.0,0.9) -- (6.0,0.1);
	
	%%%%%%%%%%%%%%%%%%%%%%
	
	\draw[red] (0.1,1.0) to [out=30,in=150] (5.9,1.0);%n2-n1
	\node at (4.0,2.0){0};
	\draw[red] (2.1,1.0) to [out=-30,in=210] (5.9,1.0);%n3-n1
	\node[above] at (4.0,0.0){0};
	\draw[red] (3.1,1.0) to [out=20,in=170] (5.9,1.0);%n1-n1
	\node[above] at (4.0,1.15){1};
	
	
	\end{tikzpicture}
	\caption{Esempio per il vincolo sul flusso in entrata \label{fig:fourthConstraintExe}}
	\end{figure*}
	In figura \ref{fig:fourthConstraintExe}, è stato espresso il vincolo che il flusso in entrata verso il nodo $n_1$ deve essere 1, cioè: 
	$M_{1,n_1,n_1}+M_{1,n_2,n_1}+M_{1,n_3,n_1}=1$.
	
\end{itemize}

Si capisce bene come questi due ultimi vincoli assicurino che la traduzione di supporto sia rispettivamente iniettiva e suriettiva, rendendola quindi \emph{biiettiva} come si voleva.



%%%   LINK GRAPH   %%%
\subsection{Vincoli per il link graph}
L'isomorfismo tra link graph è un isomorfismo tra ipergrafi. In questo problema, sfruttiamo soprattutto la definizione di link graph: la sua struttura è definita dalla funzione \emph{link}, che collega Punti a Handles. I primi sono l'insieme delle porte e degli inner names, mentre i secondi sono l'insieme degli archi e degli outer names (sottosezione \ref{sub:linkGraph}). Si può quindi vedere ogni link graph come una funzione che ha come dominio i Punti e come codominio gli Handles. 

Sulla base di queste osservazioni, possiamo costruire la \emph{rete di flusso} per questo problema nel seguente modo: innanzitutto chiamiamo i due link graph rispettivamente $L_F$ e $L_G$, e le loro funzioni come $link_F$ e $link_G$ (definite dagli archi verdi di figura \ref{fig:linkFlow}). Possiamo collegare tutti gli elementi del dominio di $link_F$ a tutti gli elementi del dominio di $link_G$, creando così archi \emph{orientati}, perchè vanno da punti di $L_F$ a punti di $L_G$, e \emph{pesati}, perchè possono assumere un valore $p \in \{0, 1\}$.
Infine, facciamo lo stesso con i loro Handle: colleghiamo tutti gli elementi del codominio di $link_F$ a tutti gli elementi del codominio di $link_G$. \\
Si è così creata la rete di flusso in figura \ref{fig:linkFlow}, dove $D_X$ (con $X \in \{ F, G\}$) indica il dominio di $link_X$ e $C_X$ il suo codominio.\\
Per chiarezza visiva, si sono omessi alcuni archi rossi, ma si deve immaginare che ogni elemento di $D_F$ abbiamo tre archi verso ognuno degli elementi di $D_G$. Lo stesso vale per $C_F$.


\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (8,5);
	%%%   First Link Graph    %%%
	%%%   Domain   %%%
	\draw[rounded corners = 2mm, dashed] (0.8,2.8) rectangle (2.0,4.2);
	\node[above] at (1.5,4.2) {$D_F$};
	%%%   Codomain   %%%
	\draw[rounded corners = 2mm, dashed] (0.8,0.8) rectangle (2.0,2.2);
	\node[above] at (1.5,0.1) {$D_G$};
	%points G
	\draw [fill] (1.5,3.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,3.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,4.0) circle [radius=0.1];%p1
	%handles G
	\draw [fill] (4.5,3.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,3.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,4.0) circle [radius=0.1];%h1
	%hyper-edges G
	\draw [myGreen, thick] (1.6,4.0) -- (4.4,4.0);
	\draw [myGreen, thick] (1.1,3.5) -- (4.9,3.5);
	\draw [myGreen, thick] (1.6,3.0) to [out=0,in=180] (3.5,3.5);
	
	%%%   Second Link Graph    %%%
	%%%   Domain   %%%
	\draw[rounded corners = 2mm, dashed] (4.0,2.8) rectangle (5.2,4.2);
	\node[above] at (4.7,4.2) {$C_F$};
	%%%   Codomain   %%%
	\draw[rounded corners = 2mm, dashed] (4.0,0.8) rectangle (5.2,2.2);
	\node[above] at (4.7,0.1) {$C_G$};
	%points H
	\draw [fill] (1.5,1.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,1.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,2.0) circle [radius=0.1];%p1
	%handles H
	\draw [fill] (4.5,1.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,1.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,2.0) circle [radius=0.1];%h1
	%hyper-edges H
	\draw [myGreen, thick] (1.6,2.0) -- (4.4,2.0);
	\draw [myGreen, thick] (1.1,1.5) -- (4.9,1.5);
	\draw [myGreen, thick] (1.6,1.0) to [out=0,in=180] (3.5,1.5);
	
	%%%   Red Edges   %%%
	\draw [red, ->] (1.4,3.0) to [out=180,in=180] (1.4,2.0);%p3-p1
	\draw [red, ->] (1.4,3.0) to [out=180,in=150] (0.9,1.5);%p3-p2
	\draw [red, ->] (1.4,3.0) to [out=180,in=120] (1.4,1.0);%p3-p3
	
	\draw [red, ->] (4.6,3.0) to [out=0,in=0] (4.6,2.0);%h3-h1
	\draw [red, ->] (4.6,3.0) to [out=0,in=30] (5.1,1.5);%h3-h2
	\draw [red, ->] (4.6,3.0) to [out=0,in=60] (4.6,1.0);%h3-h3
	
	
	\end{tikzpicture}
	\caption{Esempio di rete di flusso per il problema di isomorfismo tra link graphs. \label{fig:linkFlow}}
\end{figure*}


Incominciamo quindi con definire le variabili del sistema di equazioni:
\begin{center}
$x_{h,h'} \in \{0, 1\} \qquad h \in Y_1 \uplus E_1 \qquad$ \\ $\qquad \qquad \qquad \qquad h' \in Y_2 \uplus E_2 \qquad$
\end{center}
\begin{center}
$y_{p,p'} \in \{0, 1\} \qquad p \in X_1 \uplus P_1 \qquad$ \\ $\qquad \qquad \qquad \qquad p' \in X_2 \uplus P_2 \qquad$
\end{center}

Si sono distinte le variabili che vanno dal dominio $D_F$ a $D_G$, che vengono chiamate $y$, da quelle che vanno dal codominio $C_F$ a $C_G$, chiamate $x$.
Le soluzioni del sistema hanno lo stesso significato che avevano nel place graph: dopo l'esecuzione, le variabili che assumeranno il valore 1 saranno solamente quelle che costituiranno la vera e propria traduzione di supporto. Quindi, anche per questo problema, valgono la proposizione \ref{prop:traduzioneSupporto} e la notazione \ref{term:matchVariabili}.

I vincoli che si devono scegliere hanno il compito di ``costituire" la funzione di traduzione di supporto, e devono quindi assicurare che essa sia biiettiva e che mantenga la struttura del primo link graph. Perciò, anche in questo caso, distinguiamo in \emph{vincoli di flusso}, per il primo problema, e in \emph{vincoli strutturali}, per il secondo.

Incominciamo con il definire i \textbf{vincoli strutturali}. Essi hanno il compito di definire una funzione che va dal primo link graph al secondo, che sia in grado di mantenere la struttura del primo. In altre parole, deve controllare se le due strutture sono \emph{compatibili}. I vincoli strutturali fanno riferimento al caso negativo, cioè descrivono nel sistema quando due punti o due handle \emph{non} possono costituire un match. Da qui i due vincoli:

\begin{itemize}
	\item
	\emph{Primo vincolo strutturale}: due handles (il primo di $L_F$ e il secondo di $L_G$) che hanno un numero diverso di pre-immagini \emph{non} possono costituire un match. In altre parole: se l'handle $h$ è immagine di due punti ma l'handle $h'$ lo è di uno solo, allora $h$ e $h'$ non possono essere associati. In formule:
	\begin{center}
	$x_{h,h'} = 0 \qquad \qquad \qquad |link^{-1}_F(h)| \ne |link^{-1}_G(h')| \qquad $ \\ $\qquad \qquad h \in Y_1 \uplus E_1$ \\ $\qquad \qquad h' \in Y_2 \uplus E_2$
	\end{center}
	In figura \ref{fig:firstLinkConstraint}, si può vedere come la variabile $x_{h_3,h_1}$ sia vincolata ad assumere il valore 0, infatti: $|link_F^{-1}(h_3)| = 0$ ma 
	$|link_G^{-1}(h_1)| = 1$, quindi $x_{h_3,h_1} = 0$.
	
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (8,5);
	%%%   First Link Graph    %%%
	%points G
	\draw [fill] (1.5,3.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,3.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,4.0) circle [radius=0.1];%p1
	%handles G
	\draw [fill] (4.5,3.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,3.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,4.0) circle [radius=0.1];%h1
	%hyper-edges G
	\draw [myGreen, thick] (1.6,4.0) -- (4.4,4.0);
	\draw [myGreen, thick] (1.1,3.5) -- (4.9,3.5);
	\draw [myGreen, thick] (1.6,3.0) to [out=0,in=180] (3.5,3.5);
	
	%%%   Second Link Graph    %%%
	%points H
	\draw [fill] (1.5,1.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,1.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,2.0) circle [radius=0.1];%p1
	%handles H
	\draw [fill] (4.5,1.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,1.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,2.0) circle [radius=0.1];%h1
	%hyper-edges H
	\draw [myGreen, thick] (1.6,2.0) -- (4.4,2.0);
	\draw [myGreen, thick] (1.1,1.5) -- (4.9,1.5);
	\draw [myGreen, thick] (1.6,1.0) to [out=0,in=180] (3.5,1.5);
	
	%%%   Red Edges   %%%
	\draw [red, ->] (4.6,3.0) to [out=0,in=0] (4.6,2.0);%h3-h1
	\node[right] at (5.0,3.0){$h_3$};
	\node[right] at (5.0,2.0){$h_1$};
	
	\end{tikzpicture}
	\caption{Esempio per il primo vincolo. \label{fig:firstLinkConstraint}}
	\end{figure*}

	
	\item
	\emph{Secondo vincolo strutturale}: se due handles ($h \in C_F$ e $h' \in C_G$) non costituiscono un match, allora neanche i punti che hanno $h$ e $h'$ come immagine lo fanno. Questo vincolo modella la seguente implicazione:
	\begin{center}
	$x_{h,h'} = 0 \qquad \Rightarrow \qquad y_{p,p'} = 0$
	\end{center}
	dove $p=link^{-1}_F(h)$ e $p'=link^{-1}_G(h')$. Esso può essere tradotto tramite la seguente equazione.
	\begin{center}
	$y_{p,p'} \le x_{link_F(p),link_G(p')} \qquad \qquad \qquad p \in X_1 \uplus P_1 \qquad \qquad \qquad \qquad$ \\ $\qquad \qquad \qquad \qquad p' \in X_2 \uplus P_2$
	\end{center}
	Si noti che questa equazione equivale all'implicazione precedente: se $x=0$, allora deve per forza essere che anche $y=0$.
	
	
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (8,5);
	%%%   First Link Graph    %%%
	%points G
	\draw [fill] (1.5,3.0) circle [radius=0.1];%p3
	\node [above] at (1.5,3.0) {$p_3$};
	\draw [fill] (1.0,3.5) circle [radius=0.1];%p2
	\node [above] at (1.0,3.5) {$p_2$};
	\draw [fill] (1.5,4.0) circle [radius=0.1];%p1
	%handles G
	\draw [fill] (4.5,3.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,3.5) circle [radius=0.1];%h2 	
	\node[right] at (5.0,3.5){$h_2$};
	\draw [fill] (4.5,4.0) circle [radius=0.1];%h1
	%hyper-edges G
	\draw [myGreen, thick] (1.6,4.0) -- (4.4,4.0);
	\draw [myGreen, thick] (1.1,3.5) -- (4.9,3.5);
	\draw [myGreen, thick] (1.6,3.0) to [out=0,in=180] (3.5,3.5);
	
	%%%   Second Link Graph    %%%
	%points H
	\draw [fill] (1.5,1.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,1.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,2.0) circle [radius=0.1];%p1
	\node [below] at (1.5,2.0) {$p_1$};
	%handles H
	\draw [fill] (4.5,1.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,1.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,2.0) circle [radius=0.1];%h1
	\node[right] at (5.0,2.0){$h_1$};
	%hyper-edges H
	\draw [myGreen, thick] (1.6,2.0) -- (4.4,2.0);
	\draw [myGreen, thick] (1.1,1.5) -- (4.9,1.5);
	\draw [myGreen, thick] (1.6,1.0) to [out=0,in=180] (3.5,1.5);
	
	%%%   Red Edges   %%%
	\draw [red, ->] (5.0,3.4) to [out=0,in=0] (4.6,2.0);%h2-h1
	\node at (5.5,2.5) {0};
	\draw [red, ->] (0.9,3.5) to [out=210,in=180] (1.4,2.0);%p2-p1
	\node at (0.5,3.0) {0};
	\draw [red, ->] (1.4,3.0) to [out=210,in=150] (1.4,2.0);%p3-p1
	\node at (1.5,2.5) {0};
	
	\end{tikzpicture}
	\caption{Esempio per il secondo vincolo. \label{fig:secondLinkConstraint}}
	\end{figure*}
	
	In figura \ref{fig:secondLinkConstraint}, si può vedere un esempio per questo vincolo. Dal primo vincolo sappiamo che $x_{h_2,h_1} = 0$ perchè 
	$|link_F^{-1}(h_2)| = 2$ mentre $link_G^{-1}(h_1) = 1$. Aggiungendo il vincolo appena descritto, ricaviamo quindi che $y_{p_2,p_1} = 0$ e $y_{p_3,p_1} = 0$. Infatti, si vede subito che i punti $p_2$ e $p_3$ non possono costituire un match con $p_1$.
\end{itemize}

Descriviamo adesso i \textbf{vincoli di flusso}, che consentono di avere una funzione biiettiva. Il caso è analogo a quello per il place graph e la notazione rimane la stessa.

\begin{itemize}
	\item
	\emph{Flusso in uscita}:
		\begin{itemize}
			\item
			\emph{$\delta^+(p)=1$}:
			Dobbiamo assicurare che ogni punto di $D_F$ sia associato ad uno e un solo punto di $D_G$, che si traduce in questa equazione:
				\begin{center}
				$\sum\limits_{p'}y_{p,p'} = 1 \qquad \qquad \qquad p \in X_1 \uplus P_1 \qquad p' \in X_2 \uplus P_2$
				\end{center}
			
									
				
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (8,5);
	%%%   First Link Graph    %%%
	%points G
	\draw [fill] (1.5,3.0) circle [radius=0.1];%p3
	\node [above] at (1.5,3.0) {$p_3$};
	\draw [fill] (1.0,3.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,4.0) circle [radius=0.1];%p1
	%handles G
	\draw [fill] (4.5,3.0) circle [radius=0.1];%h3
	\node[above] at (4.5,3.0){$h_3$};
	\draw [fill] (5.0,3.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,4.0) circle [radius=0.1];%h1
	%hyper-edges G
	\draw [myGreen, thick] (1.6,4.0) -- (4.4,4.0);
	\draw [myGreen, thick] (1.1,3.5) -- (4.9,3.5);
	\draw [myGreen, thick] (1.6,3.0) to [out=0,in=180] (3.5,3.5);
	
	%%%   Second Link Graph    %%%
	%points H
	\draw [fill] (1.5,1.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,1.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,2.0) circle [radius=0.1];%p1
	%handles H
	\draw [fill] (4.5,1.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,1.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,2.0) circle [radius=0.1];%h1
	%hyper-edges H
	\draw [myGreen, thick] (1.6,2.0) -- (4.4,2.0);
	\draw [myGreen, thick] (1.1,1.5) -- (4.9,1.5);
	\draw [myGreen, thick] (1.6,1.0) to [out=0,in=180] (3.5,1.5);
	
	%%%   Red Edges   %%%
	\draw [red, ->] (1.4,3.0) to [out=230,in=130] (1.4,2.0);%p3-p1
	\node at (0.5,2.0) {0};
	\draw [red, ->] (1.4,3.0) to [out=180,in=180] (0.9,1.5);%p3-p2
	\node at (1.0,1.0) {1};
	\draw [red, ->] (1.4,3.0) to [out=180,in=180] (1.4,1.0);%p3-p3
	\node at (1.5,2.5) {0};
	
	\draw [red, ->] (4.6,3.0) to [out=0,in=0] (4.6,2.0);%h3-h1
	\node at (4.5,2.5) {0};
	\draw [red, ->] (4.6,3.0) to [out=0,in=0] (5.1,1.5);%h3-h2
	\node at (5.5,2.0) {0};
	\draw [red, ->] (4.6,3.0) to [out=0,in=0] (4.6,1.0);%h3-h3
	\node at (5.0,0.8) {1};
	
	
	\end{tikzpicture}
	\caption{Esempio per i due vincoli sul flusso in uscita. \label{fig:outFlowLinkConstraint}}
	\end{figure*}
			
			\item
			\emph{$\delta^+(h)=1$}:
			E' l'analogo del caso precedente. Ogni handle di $C_F$ deve essere associato ad uno e un solo handle di $C_G$. La rispettiva equazione è:
				\begin{center}
				$\sum\limits_{h'}y_{h,h'} = 1 \qquad \qquad \qquad h \in Y_1 \uplus E_1 \qquad p' \in Y_2 \uplus E_2$
				\end{center}

			
			La figura \ref{fig:outFlowLinkConstraint} mostra un esempio di questi due vincoli.

		\end{itemize}
		
		
	\item
	\emph{Flusso in entrata}:
		\begin{itemize}
			\item
			\emph{$\delta^-(p')=1$}: ogni punto di $D_G$ può essere associato ad uno e un solo punto di $D_F$. In formule:
				\begin{center}
				$\sum\limits_{p}y_{p,p'} = 1 \qquad \qquad \qquad p \in X_1 \uplus P_1 \qquad p' \in X_2 \uplus P_2$
				\end{center}
				
			
			\item
			\emph{$\delta^-(h')=1$}: ogni handle di $C_G$ può essere associato ad uno e un solo handle di $C_F$. In formule:
				\begin{center}
				$\sum\limits_{h}y_{h,h'} = 1 \qquad \qquad \qquad h \in Y_1 \uplus E_1 \qquad p' \in Y_2 \uplus E_2$
				\end{center}
			La figura \ref{fig:inFlowLinkConstraint} mostra un esempio per questi due vincoli.
			
			
	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (8,5);
	%%%   First Link Graph    %%%
	%points G
	\draw [fill] (1.5,3.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,3.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,4.0) circle [radius=0.1];%p1
	%handles G
	\draw [fill] (4.5,3.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,3.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,4.0) circle [radius=0.1];%h1
	%hyper-edges G
	\draw [myGreen, thick] (1.6,4.0) -- (4.4,4.0);
	\draw [myGreen, thick] (1.1,3.5) -- (4.9,3.5);
	\draw [myGreen, thick] (1.6,3.0) to [out=0,in=180] (3.5,3.5);
	
	%%%   Second Link Graph    %%%
	%points H
	\draw [fill] (1.5,1.0) circle [radius=0.1];%p3
	\draw [fill] (1.0,1.5) circle [radius=0.1];%p2
	\draw [fill] (1.5,2.0) circle [radius=0.1];%p1
	\node[below] at (1.5,2.0){$p_1$};
	%handles H
	\draw [fill] (4.5,1.0) circle [radius=0.1];%h3
	\draw [fill] (5.0,1.5) circle [radius=0.1];%h2
	\draw [fill] (4.5,2.0) circle [radius=0.1];%h1
	\node[below] at (4.5,2.0){$h_1$};
	%hyper-edges H
	\draw [myGreen, thick] (1.6,2.0) -- (4.4,2.0);
	\draw [myGreen, thick] (1.1,1.5) -- (4.9,1.5);
	\draw [myGreen, thick] (1.6,1.0) to [out=0,in=180] (3.5,1.5);
	
	%%%   Red Edges   %%%
	\draw [red, ->] (1.4,4.0) to [out=180,in=180] (1.4,2.0);%p1-p1
	\node at (1.0,4.0) {1};
	\draw [red, ->] (0.9,3.5) to [out=180,in=180] (1.4,2.0);%p2-p1
	\node at (0.5,3.5) {0};
	\draw [red, ->] (1.4,3.0) to [out=230,in=130] (1.4,2.0);%p3-p1
	\node at (1.5,2.5) {0};
	
	\draw [red, ->] (4.6,4.0) to [out=0,in=0] (4.6,2.0);%h1-h1
	\node at (5.0,4.0) {1};
	\draw [red, ->] (5.1,3.5) to [out=0,in=0] (4.6,2.0);%h2-h1
	\node at (5.5,3.0) {0};
	\draw [red, ->] (4.6,3.0) to [out=0,in=0] (4.6,2.0);%h3-h1
	\node at (4.5,2.5) {0};
	
	
	\end{tikzpicture}
	\caption{Esempio per i due vincoli sul flusso in entrata. \label{fig:inFlowLinkConstraint}}
	\end{figure*}
			
			\end{itemize}
\end{itemize}

Si noti che i quattro vincoli di flusso assicurano la iniettività e la suriettività della funzione di traduzione di supporto, rendendola quindi \emph{biiettiva}.


\subsection{Vincoli di coerenza}
Nella sottosezione \ref{sub:isoExamples}, dedicata ad alcuni esempi, la figura \ref{fig:falseIso} mostrava due bigrafi che, pur avendo i place graphs ed i link graphs isomorfi, \emph{non} erano tali. Questo perchè il sistema di equazioni non era completo: non bastano cioè i vincoli visti fino ad ora, e bisogna integrarli con dei \textbf{vincoli di coerenza} che sono dedicati all'unione delle due soluzioni.

Nell'esempio citato, si era già notato informalmente che il quadrato collegato al cerchio nel primo link graph deve essere quello più esterno nel primo place graph. Diamo ora le definizioni formali di questi vincoli:

\begin{itemize}
	\item
	\emph{Primo vincolo di coerenza}: due porte costituiscono un match nei due link graphs \emph{se e solo se} i rispettivi nodi lo fanno nei due place graphs e le due porte hanno lo stesso indice. In formule:
		\begin{center}
		$y_{p,p'} = M_{d,m,m'} \qquad \qquad \qquad p=(m,i) \qquad p'=(m',i) \qquad \qquad$ \\ 
		$\qquad \qquad \qquad p \in P_F \qquad p' \in P_G$ \\ 
		$\qquad \qquad \qquad m \in V_F \qquad m' \in V_G$ \\ 
		$i \in \mathbb{N}$ 
		\end{center}
	In altre parole, se due nodi $m$ e $m'$ non costituiscono un match nei due place graphs, allora neanche le loro porte lo fanno. D'altra parte, se $m$ e $m'$ costituiscono un match, cioè $M_{d,m,m'}=1$, allora le porte con lo stesso indice devono costituire un match: $y_{p,p'} = 1$.
	
	\item
	\emph{Secondo vincolo di coerenza}: due porte con indici diversi non possono costituire un match. In formule:
		\begin{center}
		$y_{p,p'} = 0 \qquad \qquad \qquad p=(m,i) \qquad p'=(m',i) \qquad $ \\ 
		$\qquad \qquad \qquad p \in P_F \qquad p' \in P_G$ \\ 
		$\qquad \qquad \qquad m \in V_F \qquad m' \in V_G$ \\ 
		$\qquad \qquad \qquad i, i' \in \mathbb{N} \qquad i \ne i'$ 
		\end{center}
	
	\item
	\emph{Terzo vincolo di coerenza}: se due punti sono di tipo diverso, cioè il primo è una porta e il secondo un inner name, allora essi non possono costituire un match.
		\begin{center}
		$y_{p,p'} = 0 \qquad \qquad \qquad p \in P_F \qquad p' \in X_G \qquad $ \\ 
		\end{center}
		Banalmente, vale anche il caso speculare, dove il primo punto è un inner name mentre il secondo è una porta:
		\begin{center}
		$y_{p,p'} = 0 \qquad \qquad \qquad p \in X_F \qquad p' \in P_G \qquad $ \\ 
		\end{center}
		
	\item
	\emph{Quarto vincolo di coerenza}: se due handles sono di tipo diverso, cioè il primo è un arco e il secondo un outername, allora essi non possono costituire un match.
		\begin{center}
		$y_{h,h'} = 0 \qquad \qquad \qquad h \in E_F \qquad h' \in Y_G \qquad $ \\ 
		\end{center}
		Il caso speculare, dove il primo handle è un outer name name mentre il secondo è un arco, è dato dalla formula:
		\begin{center}
		$y_{h,h'} = 0 \qquad \qquad \qquad h \in Y_F \qquad h' \in E_G \qquad $ \\ 
		\end{center}
	
	\item
	\emph{Quinto vincolo di coerenza}: un nodo può costituire un match solo un altro nodo. Lo stesso vale per le radici e per i siti. Perciò, è impossibile che esista una variabile con valore 1 da una radice verso un nodo, per esempio.
		\begin{center}
		$M_{d,a,b} = 0 \qquad \qquad$ se $ \qquad a \in n \qquad b \in V_G $\\
		oppure se $ \qquad \qquad \qquad a \in n \qquad b \in m $\\
		oppure se $ \qquad \qquad \qquad a \in m \qquad b \in V_G $\\
		oppure se $ \qquad \qquad \qquad a \in m \qquad b \in n $\\
		oppure se $ \qquad \qquad \qquad a \in V_F \qquad b \in m $\\
		oppure se $ \qquad \qquad \qquad a \in V_F \qquad b \in n $\\
		\end{center}
	\item
	\emph{Sesto vincolo di coerenza}: due nodi con controlli diversi non possono costituire un match. Per esempio, in figura \ref{fig:falseIso} il quadrato più grande del primo bigrafo non può essere associato con il cerchio del secondo.
	\begin{center}
	$M_{d,a,b} = 0 \qquad \qquad \qquad ctrl_F(a) \ne ctrl_G(b)$
	\end{center}
	
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grafo degli stati}
Sono stati elencati tutti i vincoli necessari per determinare l'isomorfismo tra bigrafi. Si è già visto che l'utilità di sapere quando due bigrafi sono uguali risiede nel fatto che è possibile fermare l'esecuzione del BRS, evitando così cicli infiniti tra due bigrafi uguali. Per memorizzare tutti gli stati assunti da un BRS durante la sua evoluzione, si è creato il \emph{grafo degli stati}: è una struttura dati a grafo dove ogni nodo è a sua volta un bigrafo. 


	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (8,5);
	%States
	\draw[thick] (0.5,0.5) circle [radius=0.5];
	\node at (0.5,0.5) {$S_0$};
	\draw[thick] (2.5,2.5) circle [radius=0.5];
	\node at (2.5,2.5) {$S_1$};
	\draw[thick] (4.5,1.5) circle [radius=0.5];
	\node at (4.5,1.5) {$S_2$};
	\draw[thick] (4.5,3.5) circle [radius=0.5];
	\node at (4.5,3.5) {$S_3$};
	\draw[thick] (6.5,2.5) circle [radius=0.5];
	\node at (6.5,2.5) {$S_4$};
	%Edges
	\draw[->, thick] (0.85,0.85) -- (2.15,2.15);%s0-s1
	\node[above left] at (1.5,1.5) {$R_1$};
	\draw[->, thick] (3.0,2.5) -- (4.0,3.5);%s1-s3
	\node at (3.5,1.5) {$R_1$};
	\draw[->, thick] (3.0,2.5) -- (4.0,1.5);%s1-s2
	\node at (3.5,3.5) {$R_1$};
	\draw[->, thick] (5.0,3.5) -- (6.0,2.5);%s2-s4
	\node at (5.5,1.5) {$R_0$};
	\draw[->, thick] (5.0,1.5) -- (6.0,2.5);%s3-s4
	\node at (5.5,3.5) {$R_0$};
	\draw[->, thick] (6.5,2.0) to [out=270,in=0] (5.5,0.0) -- (3.5,0.0) to [out=180,in=270] (2.5,2.0) ;%s4-s1
	\node[above] at (4.5,0.0) {$R_2$};
	
	\end{tikzpicture}
	\caption{Esempio di grafo degli stati. \label{fig:stateGraphExe}}
	\end{figure*}


Come si può vedere dalla figura \ref{fig:stateGraphExe}, ogni nodo è etichettato con la stringa $S_i$, perchè si tratta di uno stato, cioè di un bigrafo. All'interno di un BRS, abbiamo visto che un bigrafo può evolversi tramite le regole di reazione, motivo per cui ogni arco orientato del grafo degli stati è etichettato con il nome della regola che ha portato dal primo stato al secondo. Nell'esempio di cui sopra, dal bigrafo iniziale $S_0$ si passa a $S_1$ tramite la regola $R_1$

Si noti un aspetto molto importante: da $S_0$ a $S_1$ la regola $R_1$ ha generato un solo nuovo stato. Questo vuol dire che il redex di $R_1$ ha una sola occorrenza in $S_0$, ed essa è stata sostituita dal reactum di $R_1$, creando così lo stato $S_1$. Però, se prendiamo in considerazione quest'ultimo stato, si vede che ora la regola $R_1$ porta a due nuovi stati. Questo perchè in $S_1$ ci sono due occorrenze del redex di $R_1$, che vengono sostituite dal suo reactum, creando rispettivamente i due nuovi stati $S_2$ e $S_3$. In altre parole: una regola di reazione può generare un diverso numero di stati a seconda del bigrafo a cui è applicata.

Infine, si presti attenzione all'arco tra $S_4$ e $S_1$. Il significato è il seguente: applico la regola $R_2$ al bigrafo $S_4$, generando un nuovo stato $S_5$. Esso è però isomorfo a $S_1$, cioè: $S_1$ e $S_5$ hanno la stessa \emph{semantica}, per cui collego $S_4$ a $S_1$. Se non ci fossimo accorti di questa propietà, allora avremmo continuato ad applicare le regole $R_0$, $R_1$ e $R_2$ all'\emph{infinito}, generando sempre nuovi stati, come in figura \ref{fig:infiniteStateGraphExe}. Ora invece, dato che ci siamo accorti che da $S_4$ siamo ritornati ad $S_1$, non applichiamo più nessuna regola, avendo quindi un grafo degli stati \emph{finito}, cioè quello di figura \ref{fig:stateGraphExe}.\\ \\




	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (14,5);
	%States
	\draw[thick] (0.5,0.5) circle [radius=0.5];
	\node at (0.5,0.5) {$S_0$};
	\draw[thick] (2.5,2.5) circle [radius=0.5];
	\node at (2.5,2.5) {$S_1$};
	\draw[thick] (4.5,1.5) circle [radius=0.5];
	\node at (4.5,1.5) {$S_2$};
	\draw[thick] (4.5,3.5) circle [radius=0.5];
	\node at (4.5,3.5) {$S_3$};
	\draw[thick] (6.5,2.5) circle [radius=0.5];
	\node at (6.5,2.5) {$S_4$};
	\draw[thick] (8.5,2.5) circle [radius=0.5];
	\node at (8.5,2.5) {$S_5$};
	\draw[thick] (10.5,1.5) circle [radius=0.5];
	\node at (10.5,1.5) {$S_6$};
	\draw[thick] (10.5,3.5) circle [radius=0.5];
	\node at (10.5,3.5) {$S_7$};
	\draw[thick] (12.5,2.5) circle [radius=0.5];
	\node at (12.5,2.5) {$S_8$};
	
	%Edges
	\draw[->, thick] (0.85,0.85) -- (2.15,2.15);%s0-s1
	\node[above left] at (1.5,1.5) {$R_1$};
	\draw[->, thick] (3.0,2.5) -- (4.0,3.5);%s1-s3
	\node at (3.5,1.5) {$R_1$};
	\draw[->, thick] (3.0,2.5) -- (4.0,1.5);%s1-s2
	\node at (3.5,3.5) {$R_1$};
	\draw[->, thick] (5.0,3.5) -- (6.0,2.5);%s2-s4
	\node at (5.5,1.5) {$R_0$};
	\draw[->, thick] (5.0,1.5) -- (6.0,2.5);%s3-s4
	\node at (5.5,3.5) {$R_0$};
	\draw[->, thick] (7.0,2.5) -- (8.0,2.5);%s4-s5
	\node[above] at (7.5,2.5) {$R_2$};
	\draw[->, thick] (9.0,2.5) -- (10.0,1.5);%s5-s6
	\node at (9.5,1.5) {$R_1$};
	\draw[->, thick] (9.0,2.5) -- (10.0,3.5);%s5-s7
	\node at (9.5,3.5) {$R_1$};
	\draw[->, thick] (11.0,1.5) -- (12.0,2.5);%s6-s8
	\node at (11.5,3.5) {$R_0$};
	\draw[->, thick] (11.0,3.5) -- (12.0,2.5);%s7-s8
	\node at (11.5,1.5) {$R_0$};
	\draw[->, thick] (13.0,2.5) -- (13.9,2.5);%s8-...
	\node[above] at (13.5,2.5) {$R_2$};
	\node[below] at (13.5,2.5) {$\dots$};
	
	\end{tikzpicture}
	\caption{Grafo degli stati infinito. \label{fig:infiniteStateGraphExe}}
	\end{figure*}



\subsection{Esempio}
In questa sottosezione, viene fornito un esempio concreto di grafo degli stati, con particolare attenzione al problema dell'evoluzione infinita. Si riprende l'esempio della rete della sottosezione \ref{sub:networkExe}. L'implementazione la si può trovare in [...]. 

Si introduce solo la segnatura del pacchetto, del router e del dominio: $K=\{pacchetto:2, \quad router:2, \quad dominio:0\}$. Chiameremo rispettivamente $Encap$ e $Decap$ le regole per l'incapsulamento e il decapsulamento dei pacchetto nei vari strati, per esempio da Http a Tcp, o da Ip a Ethernet. Ci concentriamo sulla regola di inoltro tra router, che è quella in figura \ref{fig:forwardRule}.



	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (14,5);
	%%%   Redex   %%%
	% Sx Big
	\draw[rounded corners = 3mm, dashed] (0.0,0.0) rectangle (3.0,4.0);%Root 1
	\draw[rounded corners = 3mm, thick] (0.3,0.3) rectangle (2.7,3.7);%Domain 1
	\draw[thick] (2.0,3.0) circle [radius=0.5];%Router 1
	\draw[rounded corners = 1mm, dashed, fill=myGrey] (2.0,0.5) rectangle (2.5,1.0);%Site 0
	\node at (2.3,0.75) {0};
	%Packet
	\draw[rounded corners=1mm, thick] (0.5,1.0) rectangle (1.7,1.7);
	\draw[rounded corners = 1mm, dashed, fill=myGrey] (1.0,1.1) rectangle (1.4,1.5);%Site 2
	\node at (1.2,1.3) {2};
	%idS
	\draw[myGreen, thick] (0.6,1.7) to [out=100,in=270] (0.5,4.2);
	\draw[fill] (0.6,1.7) circle [radius=0.05];
	\node[above] at (0.4,4.2) {$id_S$};
	%idR
	\draw[rounded corners = 5mm, myGreen, thick] (1.6,1.7) -- (2.0,1.9) -- (3.2,1.8) -- (5.0,1.5) -- (6.0,1.5) -- (6.0,4.2);
	\draw[fill] (1.6,1.7) circle [radius=0.05];
	\node[above] at (6.3,4.2) {$id_R$};
	
	%Dx Big
	\draw[rounded corners = 3mm, dashed] (3.5,0.0) rectangle (6.5,4.0);%Root 2
	\draw[rounded corners = 3mm, thick] (3.8,0.3) rectangle (6.2,3.7);%Domain 2
	\draw[thick] (4.5,3.0) circle [radius=0.5];%Router 2
	\draw[rounded corners = 1mm, dashed, fill=myGrey] (4.0,0.5) rectangle (4.5,1.0);%Site 1
	\node at (4.3,0.75) {1};
	
	%LinkR
	\draw[myGreen, thick] (2.0,3.5) to [out=90,in=270] (3.15,4.5);%r1-link
	\draw[fill] (2.0,3.5) circle [radius=0.05];
	\draw[myGreen, thick] (4.5,3.5) to [out=90,in=270] (3.15,4.5);%r2-link
	\draw[fill] (4.5,3.5) circle [radius=0.05];
	\node[above] at (3.15,4.5) {link};
	%LocalS
	\draw[rounded corners = 3mm, myGreen, thick] (2.0,2.5) -- (2.0,2.1) -- (1.2,2.1) -- (1.2,4.5);
	\draw[fill] (2.0,2.5) circle [radius=0.05];
	\node[above] at (1.2,4.5) {$local_S$};
	%LocalR
	\draw[rounded corners = 3mm, myGreen, thick] (4.5,2.5) -- (4.5,2.1) -- (5.3,2.1) -- (5.3,4.5);
	\draw[fill] (4.5,2.5) circle [radius=0.05];
	\node[above] at (5.3,4.5) {$local_R$};
	
	
	\draw[->, red, very thick] (6.8,2.0) -- (7.8,2.0);
	
	%%%   Reactum   %%%
	% Sx Big
	\draw[rounded corners = 3mm, dashed] (8.0,0.0) rectangle (11.0,4.0);%Root 1
	\draw[rounded corners = 3mm, thick] (8.3,0.3) rectangle (10.7,3.7);%Domain 1
	\draw[thick] (10.0,3.0) circle [radius=0.5];%Router 1
	\draw[rounded corners = 1mm, dashed, fill=myGrey] (10.0,0.5) rectangle (10.5,1.0);%Site 0
	\node [below] at (10.3,1.0) {0};
	
	%Dx Big
	\draw[rounded corners = 3mm, dashed] (11.3, 0.0) rectangle (13.99,4.0);%Root 2
	\draw[rounded corners = 3mm, thick] (11.6,0.3) rectangle (13.6,3.7);%Domain 2
	\draw[thick] (12.5,3.0) circle [radius=0.5];%Router 2
	\draw[rounded corners = 1mm, dashed, fill=myGrey] (12.0,0.4) rectangle (12.5,0.9);%Site 1
	\node [below] at (12.3,0.9) {1};
	%Packet
	\draw[rounded corners=1mm, thick] (12.0,1.0) rectangle (13.2,1.7);
	\draw[rounded corners = 1mm, dashed, fill=myGrey] (12.5,1.1) rectangle (13.0,1.5);%Site 2
	\node at (12.7,1.3) {2};
	%idS
	\draw[rounded corners = 5mm, myGreen, thick] (12.0,1.7) -- (11.0,1.9) -- (8.5,1.5) -- (8.5,4.2);
	\draw[fill] (12.0,1.7) circle [radius=0.05];
	\node[above] at (8.4,4.2) {$id_S$};
	%idR
	\draw[rounded corners = 5mm, myGreen, thick] (13.2,1.7) to [out=60,in=270] (13.9,4.2);
	\draw[fill] (13.2,1.7) circle [radius=0.05];
	\node[above] at (13.59,4.0) {$id_R$};
	
	%LinkR
	\draw[myGreen, thick] (10.0,3.5) to [out=90,in=270] (11.15,4.5);%r1-link
	\draw[fill] (10.0,3.5) circle [radius=0.05];
	\draw[myGreen, thick] (12.5,3.5) to [out=90,in=270] (11.15,4.5);%r2-link
	\draw[fill] (12.5,3.5) circle [radius=0.05];
	\node[above] at (11.15,4.5) {link};
	%LocalS
	\draw[rounded corners = 3mm, myGreen, thick] (10.0,2.5) -- (10.0,2.1) -- (9.2,2.1) -- (9.2,4.5);
	\draw[fill] (10.0,2.5) circle [radius=0.05];
	\node[above] at (9.2,4.5) {$local_S$};
	%LocalR
	\draw[rounded corners = 3mm, myGreen, thick] (12.5,2.5) -- (12.5,2.1) -- (13.2,2.1) -- (13.2,4.5);
	\draw[fill] (12.5,2.5) circle [radius=0.05];
	\node[above] at (13.0,4.5) {$local_R$};
	
	\end{tikzpicture}
	\caption{Regola di inoltro tra router. \label{fig:forwardRule}}
	\end{figure*}



La regola è molto semplice. Innanzitutto, incominciamo con i vari controlli. Figli diretti delle due radici sono i due rettangoli: essi sono i domini di cui fanno parte i due router. Questi ultimi, a loro volta, sono disegnati come circonferenze con due porte: la prima collegata a ``$Link$" e la seconda a ``$Local$". Infine, il pacchetto è rappresentato da un rettangolo, anch'esso con due porte: la prima, che è quella più a sinistra, è collegata al mittente, mentre la seconda al destinatario. 

Passiamo ora a definire il ruolo degli outername. ``$Link$" è l'outername dedicato alla connessione tra router: se un terzo router volesse collegarsi a questi due, allora dovrebbe collegare (nel vero senso della parola) la sua porta superiore con ``Link". Si ricordi quanto detto nella sottosezione \ref{sub:networkExe}: i router inoltrano non deterministicamente ogni pacchetto verso tutte le sue interfacce. Se tre router sono collegati all'outername ``Link", allora uno di questi inoltra il pacchetto verso tutti gli altri due. Per cui ``$Link$" rappresenta l'insieme di tutte le interfacce di un router.

Gli outername ``$Local_S$" e ``$Local_R$" sono a disposizione solamente per gli host del dominio corrente. Per esempio, a ``$Local_S$" (che sta per \emph{Local Sender}) si possono collegare solo gli host del dominio in cui si trova il primo router. Nella regola di figura \ref{fig:forwardRule}, questi host vengono inglobati dal sito numero 0. Il medesimo discorso vale per ``$Local_R$".

Il pacchetto è collegato a due outername. Il primo, quello più a sinistra, è ``$id_S$" (\emph{id Sender}), mentre il secondo è  ``$id_R$" (\emph{id Receiver}). Nella realtà, questi due outername saranno gli identificativi del mittente e del destinatario. Se per esempio il pacchetto in questione è IP, allora $id_S$ sarà l'indirizzo IP del mittente, mentre $id_R$ quello del destinatario.

Infine, si noti anche il sito numero 2: si trova dentro il pacchetto e permette di astrarre al tipo di pacchetto. Per esempio: se è un pacchetto IP, allora è probabile che abbia incapsulato al suo interno un pacchetto TCP, che a sua volta contiene un pacchetto IP. Onde evitare di scrivere regole ad hoc per ogni tipo di pacchetto, si introduce il sito numero 2, così che la regola trovi un occorrenza (e quindi scatti) per qualsiasi tipo di pacchetto.

Vediamo ora un esempio reale, proposto in figura \ref{fig:forwardRuleBig}. Siano $D_S$ e $D_R$ i domini rispettivamente del mittente (sender) e del destinatario (receiver). Indicheremo con il triangolo il controllo per un host. Quindi $h_1$ e $h_2$ saranno rispettivamente all'interno di $D_S$ e $D_R$. Lo stesso vale per i router, cioè $R_S$ e $R_R$. Supponiamo che il pacchetto sia di tipo IP, così che $h_1$ sia collegato per esempio a $158.110.3.46$, e $h_2$ a $158.110.144.31$. Infine, alla porta inferiore di $R_S$ si collegherà $h_1$, mentre a quella di $R_R$ si collegherà $id_2$.


	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (10,5);
	%%%   Redex   %%%
	% Sx Big
	\draw[rounded corners = 3mm, dashed] (0.0,0.0) rectangle (3.0,4.0);%Root 1
	\draw[rounded corners = 3mm, thick] (0.3,0.3) rectangle (2.7,3.7);%Domain 1
	\node at (2.0,4.2){$D_S$};
	\draw[thick] (2.0,3.0) circle [radius=0.5];%Router 1
	\node at (2.0,3.0){$R_S$};
	\draw[rounded corners = 1mm, thick] (0.7,0.5) -- (1.5,0.5) -- (1.1,1.2) -- (0.7,0.5);%h1
	\node at (1.15,0.75) {$h_1$};
	%Packet
	\draw[rounded corners=1mm, thick] (1.4,1.0) rectangle (2.6,1.7);
	\draw[rounded corners = 1mm, thick, fill=myGrey] (1.6,1.1) rectangle (2.4,1.5);%tcp
	\node at (2.0,1.3) {tcp};
	%packet - idS
	\draw[myGreen, thick] (1.5,1.7) to [out=90,in=300] (0.83,2.5);
	\draw[fill] (1.5,1.7) circle [radius=0.05];
	%packet - idR
	\draw[myGreen, thick] (2.5,1.7) to [out=60,in=230] (5.72,2.5);
	\draw[fill] (2.5,1.7) circle [radius=0.05];
	
	
	%Dx Big
	\draw[rounded corners = 3mm, dashed] (3.5,0.0) rectangle (6.5,4.0);%Root 2
	\draw[rounded corners = 3mm, thick] (3.8,0.3) rectangle (6.2,3.7);%Domain 2
	\node at (4.5,4.2){$D_R$};
	\draw[thick] (4.5,3.0) circle [radius=0.5];%Router 2
	\node at (4.5,3.0){$R_R$};
	\draw[rounded corners = 1mm, thick] (5.0,0.5) -- (5.8,0.5) -- (5.4,1.3) -- (5.0,0.5);%h2
	\node at (5.4,0.75) {$h_2$};
	
	%LinkR
	\draw[myGreen, thick] (2.0,3.5) to [out=90,in=270] (3.15,4.5);%r1-link
	\draw[fill] (2.0,3.5) circle [radius=0.05];
	\draw[myGreen, thick] (4.5,3.5) to [out=90,in=270] (3.15,4.5);%r2-link
	\draw[fill] (4.5,3.5) circle [radius=0.05];
	\node[above] at (3.15,4.5) {link};
	%idS
	\node[above] at (0.4,4.2) {$158.110.3.46$};
	\draw[rounded corners = 3mm, myGreen, thick] (1.1,1.2) to [out=90,in=270] (0.4,4.2);
	\draw[fill] (1.1,1.2) circle [radius=0.05];
	%idR
	\node[above] at (6.3,4.2) {$158.110.144.31$};
	\draw[rounded corners = 3mm, myGreen, thick] (5.4,1.3) to [out=90,in=270] (6.3,4.2);
	\draw[fill] (5.4,1.3) circle [radius=0.05];
	%LocalS
	\draw[rounded corners = 3mm, myGreen, thick] (1.1,0.5) -- (1.1,0.2) --  (2.0,0.2) -- (2.0,2.5);
	\draw[fill] (2.0,2.5) circle [radius=0.05];
	\draw[fill] (1.1,0.5) circle [radius=0.05];
	%LocalR
	\draw[rounded corners = 3mm, myGreen, thick] (5.4,0.5) -- (5.4,0.2) -- (4.5,0.2) -- (4.5,2.5);
	\draw[fill] (4.5,2.5) circle [radius=0.05];
	\draw[fill] (5.4,0.5) circle [radius=0.05];
	
	
	\end{tikzpicture}
	\caption{Bigrafo di partenza \label{fig:networkRuleExe}}
	\end{figure*}


Chiamiamo il bigrafo della figura \ref{fig:networkRuleExe} come $S_0$, cioè lo stato iniziale del grafo degli stati. Il nostro BRS è formato da una sola regola, cioè quella di figura \ref{fig:forwardRule}, che chiameremo $R_0$. Si noti come il redex di $R_0$ trovi una ed una sola occorrenza in $S_0$, e quindi genererà un solo stato, ovvero $S_1$, dove il pacchetto si è spostano in $D_R$, arrivando a destinazione. Si può vedere questo risultato nel bigrafo di figura \ref{fig:forwardRuleBigPost}, che sarà quindi $S_1$.



	\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (10,5);
	%%%   Redex   %%%
	% Sx Big
	\draw[rounded corners = 3mm, dashed] (0.0,0.0) rectangle (3.0,4.0);%Root 1
	\draw[rounded corners = 3mm, thick] (0.3,0.3) rectangle (2.7,3.7);%Domain 1
	\node at (2.0,4.2){$D_S$};
	\draw[thick] (2.0,3.0) circle [radius=0.5];%Router 1
	\node at (2.0,3.0){$R_S$};
	\draw[rounded corners = 1mm, thick] (0.7,0.5) -- (1.5,0.5) -- (1.1,1.2) -- (0.7,0.5);%h1
	\node at (1.15,0.75) {$h_1$};
	%Packet
	\draw[rounded corners=1mm, thick] (3.8,1.0) rectangle (5.0,1.7);
	\draw[rounded corners = 1mm, thick, fill=myGrey] (4.0,1.1) rectangle (4.8,1.5);%Tcp
	\node at (4.4,1.3) {tcp};
	%packet - idS
	\draw[myGreen, thick] (3.9,1.7) to [out=90,in=300] (0.83,2.5);
	\draw[fill] (3.9,1.7) circle [radius=0.05];
	%packet - idR
	\draw[myGreen, thick] (4.9,1.7) to [out=60,in=230] (5.72,2.5);
	\draw[fill] (4.9,1.7) circle [radius=0.05];
	
	
	%Dx Big
	\draw[rounded corners = 3mm, dashed] (3.5,0.0) rectangle (6.5,4.0);%Root 2
	\draw[rounded corners = 3mm, thick] (3.8,0.3) rectangle (6.2,3.7);%Domain 2
	\node at (4.5,4.2){$D_R$};
	\draw[thick] (4.5,3.0) circle [radius=0.5];%Router 2
	\node at (4.5,3.0){$R_R$};
	\draw[rounded corners = 1mm, thick] (5.0,0.5) -- (5.8,0.5) -- (5.4,1.3) -- (5.0,0.5);%h2
	\node at (5.4,0.75) {$h_2$};
	
	%LinkR
	\draw[myGreen, thick] (2.0,3.5) to [out=90,in=270] (3.15,4.5);%r1-link
	\draw[fill] (2.0,3.5) circle [radius=0.05];
	\draw[myGreen, thick] (4.5,3.5) to [out=90,in=270] (3.15,4.5);%r2-link
	\draw[fill] (4.5,3.5) circle [radius=0.05];
	\node[above] at (3.15,4.5) {link};
	%idS
	\node[above] at (0.4,4.2) {$158.110.3.46$};
	\draw[rounded corners = 3mm, myGreen, thick] (1.1,1.2) to [out=90,in=270] (0.4,4.2);
	\draw[fill] (1.1,1.2) circle [radius=0.05];
	%idR
	\node[above] at (6.3,4.2) {$158.110.144.31$};
	\draw[rounded corners = 3mm, myGreen, thick] (5.4,1.3) to [out=90,in=270] (6.3,4.2);
	\draw[fill] (5.4,1.3) circle [radius=0.05];
	%LocalS
	\draw[rounded corners = 3mm, myGreen, thick] (1.1,0.5) -- (1.1,0.2) --  (2.0,0.2) -- (2.0,2.5);
	\draw[fill] (2.0,2.5) circle [radius=0.05];
	\draw[fill] (1.1,0.5) circle [radius=0.05];
	%LocalR
	\draw[rounded corners = 3mm, myGreen, thick] (5.4,0.5) -- (5.4,0.2) -- (4.5,0.2) -- (4.5,2.5);
	\draw[fill] (4.5,2.5) circle [radius=0.05];
	\draw[fill] (5.4,0.5) circle [radius=0.05];
	
	
	\end{tikzpicture}
	\caption{Bigrafo dopo l'applicazione della regola $R_0$ \label{fig:forwardRuleBigPost}}
	\end{figure*}


Di per sè, il BRS si dimentica degli stati precedenti, in questo caso $S_0$. Per cui, da $S_1$ scatterebbe di nuovo la regola $R_0$, creando lo stato $S_2$. A sua volta, da $S_2$, eseguirebbe di nuovo $R_0$ e causerebbe così un'esecuzione infinita, dando luogo al grafo degli stati in figura \ref{fig:infiniteStateGraphNetwork}.

Grazie all'isomorfismo tra bigrafi, riusciamo a collegare lo stato $S_1$ a $S_0$. Poichè da $S_1$ tramite la regola $R_0$ viene creato lo stato $S_2$, siamo ora in grado non doverlo più memorizzare, in quanto è uguale (o meglio, è semanticamente equivalente) allo stato $S_0$. Per cui, ritrovandoci di nuovo in $S_0$, sappiamo che non dobbiamo applicare più nessuna regola, pena un'esecuzione infinita del BRS. Tramite l'isomorfismo, si è potuto generare il \emph{grafo degli stati} della figura \ref{fig:finiteStateGraphNetwork}.



\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (14,5);
	%States
	\draw[thick] (0.5,0.5) circle [radius=0.5];
	\node at (0.5,0.5) {$S_0$};
	\draw[thick] (2.5,0.5) circle [radius=0.5];
	\node at (2.5,0.5) {$S_1$};
	\draw[thick] (4.5,0.5) circle [radius=0.5];
	\node at (4.5,0.5) {$S_2$};
	\draw[thick] (6.5,0.5) circle [radius=0.5];
	\node at (6.5,0.5) {$S_3$};
	
	%Edges
	\draw[->, thick] (1.0,0.5) -- (2.0,0.5);%s0-s1
	\node[above] at (1.5,0.5) {$R_0$};
	\draw[->, thick] (3.0,0.5) -- (4.0,0.5);%s1-s2
	\node[above] at (3.5,0.5) {$R_0$};
	\draw[->, thick] (5.0,0.5) -- (6.0,0.5);%s2-s3
	\node[above] at (5.5,0.5) {$R_0$};
	\draw[->, thick] (7.0,0.5) -- (8.0,0.5);%s3-...
	\node[above] at (7.5,0.5) {$\dots$};
	
	\end{tikzpicture}
	\caption{Grafo degli stati infinito. \label{fig:infiniteStateGraphNetwork}}
\end{figure*}




\begin{figure*}[th]
	\centering
	\begin{tikzpicture}
	%\draw[help lines] (0,0) grid (14,5);
	%States
	\draw[thick] (1.5,1.5) circle [radius=0.5];
	\node at (1.5,1.5) {$S_0$};
	\draw[thick] (3.5,1.5) circle [radius=0.5];
	\node at (3.5,1.5) {$S_1$};
	
	%Edges
	\draw[->, thick] (1.85,1.85) to [out=45,in=135] (3.15,1.85);%s0-s1
	\node at (2.5,2.5) {$R_0$};
	\draw[<-, thick] (1.85,1.15) to [out=-45,in=-135] (3.15,1.15);%s1-s0
	\node at (2.5,0.5) {$R_0$};
		
	\end{tikzpicture}
	\caption{Grafo degli stati finito. \label{fig:finiteStateGraphNetwork}}
\end{figure*}











